% \CheckSum{711}
% \iffalse meta-comment
% ======================================================================
% scrkbase.dtx
% Copyright (c) Markus Kohm, 2002-2007
%
% This file is part of the LaTeX2e KOMA-Script bundle.
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3b of the license.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3b or later is part of all distributions of LaTeX 
% version 2005/12/01 or later and of this work.
%
% This work has the LPPL maintenance status "author-maintained".
%
% The Current Maintainer and author of this work is Markus Kohm.
%
% This work consists of all files listed in manifest.txt.
% ----------------------------------------------------------------------
% scrkbase.dtx
% Copyright (c) Markus Kohm, 2002-2007
%
% Dieses Werk darf nach den Bedingungen der LaTeX Project Public Lizenz,
% Version 1.3b, verteilt und/oder veraendert werden.
% Die neuste Version dieser Lizenz ist
%   http://www.latex-project.org/lppl.txt
% und Version 1.3b ist Teil aller Verteilungen von LaTeX
% Version 2005/12/01 oder spaeter und dieses Werks.
%
% Dieses Werk hat den LPPL-Verwaltungs-Status "author-maintained"
% (allein durch den Autor verwaltet).
%
% Der Aktuelle Verwalter und Autor dieses Werkes ist Markus Kohm.
% 
% Dieses Werk besteht aus den in manifest.txt aufgefuehrten Dateien.
% ======================================================================
% \fi
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
% \iffalse
%%% From File: scrkbase.dtx
%<*driver>
% \fi
\ProvidesFile{scrkbase.dtx}[2007/03/08 v2.97b KOMA-Script (basics)]
% \iffalse
%</driver>
%<package&option>\ProvidesPackage{scrkbase}[%
%<package&option>  \KOMAScriptVersion\space package (basics and keyval use)]
%<*driver>
\documentclass{scrdoc}
\usepackage[english,ngerman]{babel}
\usepackage[latin1]{inputenc}
\CodelineIndex
\RecordChanges
\GetFileInfo{scrkbase.dtx}
\title{\KOMAScript{} \partname\ \texttt{\filename}%
  \footnote{Dies ist Version \fileversion\ von Datei
    \texttt{\filename}.}}
\date{\filedate}
\author{Markus Kohm}

\begin{document}
  \maketitle
  \tableofcontents
  \DocInput{\filename}
\end{document}
%</driver>
% \fi
%
% \selectlanguage{ngerman}
%
% \changes{v1.0}{2002/07/06}{Beginn der ersten Version}
%
% \section{Grundlegenden \KOMAScript-Erweiterungen}
%
% Neue Versionen von \KOMAScript{} machen zunehmend Gebrauch vom
% \textsf{keyval}-Paket. Das \textsf{keyval}-Paket ist Bestandteil des
% \textsf{graphics}-Pakets und muss als solches auf allen
% \TeX-Systemen mit \LaTeX{} enthalten sein. Es genügt jedoch in
% einigen Punkten nicht den Anforderungen von \KOMAScript{}. Deshalb
% werden hier Erweiterungen vorgenommen, die von \KOMAScript-Klassen
% und \KOMAScript-Paketen verwendet werden können.
%
% Darüber hinaus werden immer mehr Teile von \KOMAScript{} von mehr
% als einem Paket oder von Paketen und Klassen verwendet. Diese
% grundlegenden Dinge wurden daher in ein eigenes Paket,
% \textsl{scrkbase}, ausgegliedert. Dadurch werden die Pakete und
% Klassen selbst kleiner und die können trotzdem unabhängig
% voneinander verwendet werden. Selbstverständlich kann man dieses
% Paket auch ohne den Rest von \KOMAScript{} zum Einsatz bringen.
%
% \StopEventually{\PrintIndex\PrintChanges}
%
% \iffalse
%<*load>
% \fi
%
% \subsection{Laden des Pakets}
% Wer das Paket lädt, tut das allerdings in der Regel sogar bereits
% vor der Definition der Optionen mit:
%    \begin{macrocode}
\RequirePackage{scrkbase}[\KOMAScriptVersion]
%    \end{macrocode}
%
% \iffalse
%</load>
%<*option>
% \fi
%
% \subsection{Laden von \textsf{keyval}}
%
% Hier wird nicht nur das Paket geladen, was ruckzuck mit:
%    \begin{macrocode}
\RequirePackage{keyval}
%    \end{macrocode}
% erledigt ist.
%
%
% \subsection{Anweisungen zur Abarbeitung von Optionen}
%
%  \begin{macro}{\scr@ifundefined}
%    \changes{v2.95c}{2006/08/12}{neu (intern)}
%    \changes{v2.97b}{2007/03/08}{vermurkste Logik korrigiert}
% Dieses Makro arbeitet wie \cs{@ifundefined}, definiert dabei aber
% ein undefiniertes Makro nicht als \cs{relax}. Es muss bereits hier definiert
% werden, weil es gleich verwendet wird.
%    \begin{macrocode}
\begingroup\expandafter\expandafter\expandafter\endgroup
\expandafter\ifx\csname ifcsname\endcsname\relax
  \newcommand{\scr@ifundefined}[1]{%
    \begingroup\expandafter\expandafter\expandafter\endgroup
    \expandafter\ifx\csname #1\endcsname\relax
      \expandafter\@firstoftwo
    \else
      \expandafter\@secondoftwo
    \fi
  }
\else
  \newcommand{\scr@ifundefined}[1]{%
    \ifcsname #1\endcsname
      \expandafter\@secondoftwo
    \else
      \expandafter\@firstoftwo
    \fi
  }
\fi
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\DeclareKeyValOption}
% Dieses Makro deklariert alle bisher definierten Schlüssel eines
% Bereichs (erste Argument) als Optionen. Das optionale Argument
% erlaubt außerdem die Deklaration einer
% \cs{DeclareOption*}-Auswertung. \cs{DeclareOption*} darf nicht
% zusammen mit dieser Anweisung verwendet werden. Diese Anweisung darf
% je Paket oder Klasse nur einmal verwendet werden.
%    \begin{macrocode}
\newcommand*{\DeclareKeyValOption}[2][%
  \ifx\@currext\@clsextension\OptionNotUsed\else\@unkownoptionerror\fi
]{%
  \DeclareOption*{%
    \def\@tempa##1=##2=##3\@nil{%
      \scr@ifundefined{KV@#2@##1}{#1}{%
        \@expandtwoargs\setkeys{#2}\CurrentOption
      }%
    }%
    \expandafter\@tempa\CurrentOption==\@nil
  }%
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Definition von KOMA-\textsf{keyval}-Schlüsseln (Basis)}
%
% Üblicherweise verwendet \KOMAScript{} für alle
% \textsf{keyval}-Schlüssel die gleiche Bereichskennung
% "`\texttt{KOMA}"'. Dadurch ist es möglich, dass Pakete die Schlüssel
% der Klassen umdefinieren und dass jeder Teil von \KOMAScript{} die
% Schlüssel jedes anderen Teils ausführen kann -- sobald sie definiert
% sind.
%
%  \begin{macro}{\KOMA@key}
% Einzig, um etwas Tipparbeit zu sparen, wird ein abkürzendes Makro
% definiert:
%    \begin{macrocode}
\newcommand*{\KOMA@key}{\define@key{KOMA}}
%    \end{macrocode}
%  \end{macro}
%
% \subsection{Optionen}
%
% \begin{option}{internalonly}
%   \changes{v2.96}{2006/11/26}{neu}
% \begin{macro}{\dont@let@as@internal@defined}
%   \changes{2.96}{2006/11/26}{neu (intern)}
% Anweisungen, die mit einem internen und einem Anwendername vorhanden sind,
% können vor dem Anwender optional verborgen werden.
%    \begin{macrocode}
\newcommand*{\dont@let@as@internal@defined}{/}
\KOMA@key{internalonly}{%
  \begingroup
    \@expandtwoargs\in@{#1}\dont@let@as@internal@defined
  \expandafter\endgroup
  \ifin@\else\g@addto@macro\dont@let@as@internal@defined{#1/}\fi
}
\DeclareKeyValOption{KOMA}
%    \end{macrocode}
% \end{macro}
% \end{option}
%
% \changes{v2.96}{2006/08/20}{Optionen werden abgearbeitet}
%    \begin{macrocode}
\ProcessOptions\relax
%    \end{macrocode}
%
% \begin{macro}{\@globaloptionslist}
%   \changes{v2.96}{2006/11/26}{new}
%   \changes{v2.96}{2006/11/26}{Klassenoptionen durchsuchen}
% Die Lister der globalen Optionen wird teilweise benötigt. Weil
% \textsl{xkeyval} dämlicherweise glaubt, es müsse alle Optionen mit
% Gleichheitszeichen aus der Liste der Klassenoptionen entfernen
% (seltsamerweise aber nicht die (x)keyval-Optionen, die ohne Wert aufgerufen
% werden, weil ihr Defaultwert verwendet werden soll), wird hier ein eigenes
% Makro definiert.
%    \begin{macrocode}
\newcommand*{\@globaloptionslist}{}
\scr@ifundefined{XKV@classooptionslist}{%
  \let\@globaloptionslist\@classoptionslist
}{%
  \let\@globaloptionslist\XKV@classoptionslist
}
\@expandtwoargs\in@{,internalonly=}{,\@globaloptionslist}
\ifin@
  \begingroup
    \catcode`\=12\catcode`\:=12
    \def\@do@internalonly #1internalonly=#2\@nil{%
      \ifx\relax#1\relax\setkeys{KOMA}{internalonly=#2}\fi
      \@expandtwoargs\@removeelement{internalonly=#2}\@unusedoptionlist
      \@unusedoptionlist
    }%
    \expandafter\@for\expandafter\@tempa\expandafter:\expandafter=%
    \@globaloptionslist\do{%
      \expandafter\@do@internalonly\@tempa\@nil
    }%
    \global\let\@unusedoptionlist\@unusedoptionlist
  \endgroup
\fi
%    \end{macrocode}
% \end{macro}
%
% \iffalse
%</option>
%<*body>
% \fi
%
% \subsection{Häufig benötigte Befehle}
%
%  \begin{macro}{\if@atdocument}
%    \changes{v2.95}{2002/12/05}{neuer Schalter}
%  \begin{macro}{\@atdocumenttrue}
%  \begin{macro}{\@atdocumentfalse}
% Dieser Schalter wird bei \cs{begin}\texttt{\{document\}} wahr. Er
% wird von \KOMAScript{} für Befehle verwendet, die sich
% unterschiedlich verhalten, je nachdem, ob sie in der Präambel oder
% danach aufgerufen werden.
%    \begin{macrocode}
\newif\if@atdocument
\AtBeginDocument{\@atdocumenttrue}
\@onlypreamble\@atdocumentrue
\@onlypreamble\@atdocumentfalse
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\let@as@internal@defined}
%    \changes{v2.95}{2002/08/19}{neu (intern)}
%    \changes{v2.95c}{2006/08/12}{Warnung bei Umdefinierung}
%    \changes{v2.96}{2006/11/26}{Herausreichen von internen Makros als
%      Benutzermakros kann verhindert werden}
% Dieses Makro wird intern verwendet, um dokumentierte Makros mit der
% Definition von internen Makros zu versehen, falls sie nicht bereits
% definiert oder als nicht zu definieren markiert sind. Der Name des
% dokumentierten Makros wird als Parameter übergeben. Dies wird gleich
% benötigt.
%    \begin{macrocode}
\newcommand*{\let@as@internal@defined}[1]{%
  \begingroup
    \@expandtwoargs\in@{/#1/}\dont@let@as@internal@defined
  \expandafter\endgroup
  \ifin@
    \PackageInfo{%
      scrkbase%
    }{%
      \expandafter\string\csname #1\endcsname\space excluded from being
      defined%
    }%
  \else
    \@ifundefined{#1}{%
      \begingroup
        \expandafter\def\expandafter\@tempa
          \expandafter{\csname scr@#1\endcsname}
        \expandafter\def\expandafter\@tempb
          \expandafter{\csname #1\endcsname}
      \expandafter\expandafter\expandafter\endgroup
      \expandafter\expandafter\expandafter\let\expandafter\@tempb\@tempa
      \if@atdocument\else
        \g@addto@macro\document{%
          \expandafter\ifx\csname #1\expandafter\endcsname
          \csname scr@#1\endcsname
          \else
            \PackageWarning{scrkbase}{%
              \expandafter\string\csname #1\endcsname\space was
              redefined\MessageBreak
              at the document preamble.\MessageBreak
              If you did not redefine it by yourself, have a\MessageBreak
              a look at the description of this command at\MessageBreak
              the manual of every package you are using\@gobble
            }%
          \fi
        }%
      \fi
    }{%
      \PackageInfo{%
        scrkbase%
      }{%
        \expandafter\string\csname #1\endcsname\space already
        defined.\MessageBreak
        If \expandafter\string\csname #1\endcsname\space does not behave
        like\MessageBreak
        it was described at the KOMA-Script manual, try to\MessageBreak
        load `scrkbase.sty' earlier or find out at which\MessageBreak
        package or class \expandafter\string\csname #1\endcsname\space
        was defined before\@gobble
      }%
    }%
  \fi
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\ifundefined}
%    \changes{v2.95}{2002/08/21}{neu}
%    \changes{v2.95c}{2006/08/12}{über interne Anweisung definiert}
% Dieses Makro arbeitet wie \cs{@ifundefined}, definiert dabei aber
% ein undefiniertes Makro nicht als \cs{relax}.
%    \begin{macrocode}
\let@as@internal@defined{ifundefined}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\ifnotundefined}
%    \changes{v2.95}{2002/08/21}{neu}
%    \changes{v2.95c}{2006/08/12}{nutzt \eTeX{} wenn möglich}
% Dieses Makro arbeitet genau umgekehrt zu \cs{ifundefined}. Manchmal
% ist es ganz nützlich, auch das zu haben. Dieses Makro heißt nicht
% \cs{ifdefined}, weil \eTeX\ bereits ein solches Primitiv bietet.
%    \begin{macrocode}
\scr@ifundefined{ifcsname}{%
  \newcommand{\ifnotundefined}[1]{%
    \begingroup\expandafter\expandafter\expandafter\endgroup
    \expandafter\ifx\csname #1\endcsname\relax
      \expandafter\@secondoftwo
    \else
      \expandafter\@firstoftwo
    \fi
  }%
}{%
  \newcommand{\ifnotundefined}[1]{%
    \ifcsname #1\endcsname
      \expandafter\@firstoftwo
    \else
      \expandafter\@secondoftwo
    \fi
  }%
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\ifstr}
%    \changes{v2.95}{2004/07/20}{if- und then-Teil werden nicht gefressen}
% Dieses Makro vergleicht zwei Tokenfolgen. Eigentlich müsste es also
% eher \cs{ifequal} oder ähnlich heißen.
%    \begin{macrocode}
\newcommand\ifstr[2]{%
  \begingroup\edef\@tempa{#1}\edef\@tempb{#2}%
  \ifx\@tempa\@tempb
    \endgroup\expandafter\@firstoftwo
  \else
    \endgroup\expandafter\@secondoftwo
  \fi
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\ifnumber}
% Dieses Makro testet, ob ein übergebener Parameter eine positive,
% ganze Zahl ist. Ist dies der Fall, wird der zweite Parameter
% ausgeführt, sonst der dritte.
%    \begin{macrocode}
\newcommand\ifnumber[1]{%
  \begingroup\@tempswafalse\let\scr@next\test@number
  \expandafter\scr@next#1\scr@next
  \if@tempswa
    \endgroup\expandafter\@firstoftwo
  \else
    \endgroup\expandafter\@secondoftwo
  \fi
}
%    \end{macrocode}
%  \begin{macro}{\test@number}
% Für den eigentlichen Test wird der erste Parameter Token für Token
% gescannt und beurteilt.
%    \begin{macrocode}
\newcommand*{\test@number}[1]{%
  \ifx \scr@next#1
    \let\scr@next\relax
  \else
%    \end{macrocode}
% Dabei wird für einen schnelleren Vergleich die Tatsache genutzt, dass
% Ziffernzeichen immer im selben durchgängigen Bereich liegen
%    \begin{macrocode}
    \@tempcnta=\expandafter\expandafter\expandafter\number
    \expandafter`#1\relax
    \ifnum \@tempcnta>47
      \ifnum \@tempcnta<58
        \@tempswatrue
      \else\@tempswafalse\fi
    \else\@tempswafalse\fi
%    \end{macrocode}
% Das zeichenweise Scannen und Parsen kann natürlich nicht einfach
% abgebrochen werden. Stattdessen ist der Parameterrest noch zu
%  entfernen.
%    \begin{macrocode}
    \if@tempswa\else\let\scr@next\gobble@till@scr@next\fi
  \fi
  \scr@next
}
%    \end{macrocode}
%  \begin{macro}{\gobble@tillscr@@next}
% Das geschieht mit einem einzigen "`Leermacro"'.
%    \begin{macrocode}
\newcommand*{\gobble@till@scr@next}{}
\def\gobble@till@scr@next#1\scr@next{}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\ifdimen}
% Dieses Makro testet, ob ein übergebener Parameter eine Dimension
% ist und führt in Abhängigkeit davon den zweiten oder dritten
% Parameter aus.
%    \begin{macrocode}
\newcommand{\ifdimen}[1]{%
  \begingroup\@tempswatrue\let\scr@next\test@posdimen
  \expandafter\test@dimen#1\scr@next
  \if@tempswa
    \endgroup\expandafter\@firstoftwo
  \else
    \endgroup\expandafter\@secondoftwo
  \fi
}
%    \end{macrocode}
%  \begin{macro}{\test@dimen}
% Als erste muss ein Vorzeichen entfernt werden.
%    \begin{macrocode}
\newcommand*{\test@dimen}[1]{%
  \ifx -#1\else\ifx +#1\else
      \def\scr@next{\let\scr@next\test@posdimen\scr@next#1}\fi\fi
  \scr@next
}
%    \end{macrocode}
%  \begin{macro}{\test@posdimen}
% Dann muss getestet werden, ob es sich beim Rest um eine Dimension
% handelt. Dabei werden der Einfachheit halber mehrere Dezimalkomma
% und -punkte erlaubt. Natürlich könnte man es auch wirklich richtig
% machen, aber das wäre nochmal etwas aufwendiger. Ist das wirklich
% notwendig? 
%    \begin{macrocode}
\newcommand*{\test@posdimen}[1]{%
  \ifx \scr@next#1%
    \@tempswafalse\let\scr@next\relax
  \else
    \if .#1\else\if ,#1\else
        \@tempcnta=%
        \expandafter\expandafter\expandafter\number\expandafter`#1\relax
        \ifnum \@tempcnta>47
          \ifnum \@tempcnta<58
          \else\def\scr@next{\test@dimunt#1}\fi
        \else\def\scr@next{\test@dimunt#1}\fi
    \fi\fi
  \fi
  \scr@next
}
%    \end{macrocode}
%  \begin{macro}{\testdimunt}
%  \begin{macro}{\test@trueunt}
% Außer einer Gleitkomma- bzw. Gleitpunktzahl muss auch noch die Einheit
% behandelt werden. Dabei sind sowohl die neun Standardeinheiten als auch
% deren "`true"'-Variante zu berücksichtigen. Deshalb wird zuerst ein
% eventuelles "`\texttt{true}"' weggeworfen.
%    \begin{macrocode}
\newcommand*{\test@dimunt}{}
\def\test@dimunt#1\scr@next{%
  \expandafter\test@trueunt#1truetrue\test@trueunt
}
\newcommand*{\test@trueunt}{}
\def\test@trueunt#1true#2true#3\test@trueunt{%
  \edef\@tempa{#1}
  \ifx\@tempa\@empty\test@@ifdimunt{#2}\else\test@@ifdimunt{#1}\fi
}
%    \end{macrocode}
%  \begin{macro}{\test@@ifdimunt}
% Anschließend wird dann getestet, ob es sich um eine der neun üblichen
% Einheiten handelt.
%    \begin{macrocode}
\newcommand*\test@@ifdimunt[1]{%
  \@tempswafalse
  \ifstr{#1}{pt}{\@tempswatrue}{%
    \ifstr{#1}{pc}{\@tempswatrue}{%
      \ifstr{#1}{in}{\@tempswatrue}{%
        \ifstr{#1}{bp}{\@tempswatrue}{%
          \ifstr{#1}{cm}{\@tempswatrue}{%
            \ifstr{#1}{mm}{\@tempswatrue}{%
              \ifstr{#1}{dd}{\@tempswatrue}{%
                \ifstr{#1}{cc}{\@tempswatrue}{%
                  \ifstr{#1}{sp}{\@tempswatrue}{}%
                }%
              }%
            }%
          }%
        }%
      }%
    }%
  }%
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%  \begin{macro}{\ifpdftex}
%    \changes{v2.95}{2002/08/19}{neu}
%  \begin{macro}{\scr@ifpdftex}
%    \changes{v2.95}{2002/08/19}{neu (intern)}
% If-then-else-Konstrukt, um zu testen, ob pdf\TeX{} verwendet wird.
%    \begin{macrocode}
\newcommand{\scr@ifpdftex}{\ifnotundefined{pdftexversion}}
\let@as@internal@defined{ifpdftex}
\BeforePackage{pdfcprot}{\let\ifpdftex\relax}
\AfterPackage{pdfcprot}{\let@as@internal@defined{ifpdftex}}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\ifvtex}
%    \changes{v2.95}{2002/08/19}{neu}
%  \begin{macro}{\scr@ifvtex}
%    \changes{v2.95}{2002/08/19}{neu}
% If-then-else-Konstrukt, um zu testen, ob V\TeX{} verwendet wird.
%    \begin{macrocode}
\newcommand{\scr@ifvtex}{\ifnotundefined{VTeXversion}}
\let@as@internal@defined{ifvtex}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\ifpdfoutput}
%    \changes{v2.7g}{2001/04/17}{neu}
%    \changes{v2.8q}{2001/10/19}{\cs{pdfoutput} wird nicht mehr zu
%      \cs{relax}, wenn zuvor undefiniert}
%    \changes{v2.8q}{2001/10/19}{darf bereits definiert sein}
%    \changes{v2.8q}{2001/10/19}{Verwendung von \cs{scr@ifpdfoutput}}
%  \begin{macro}{\scr@ifpdfoutput}
%    \changes{v2.8q}{2001/10/19}{neu (intern)}
%    \changes{v2.8q}{2001/11/13}{funktioniert}
%    \changes{v2.95}{2002/08/21}{berücksichtigt V\TeX}
%    \changes{v2.95}{2004/07/20}{Expandierbarkeit verbessert}
% If-then-else-Konstrukt, um abhängig davon, ob als \texttt{pdf}
% ausgegeben wird oder nicht, Befehle auszuführen. Dieses Makro wird
% für die Deklaration der Option \texttt{pagesize} benötigt.
%    \begin{macrocode}
\newcommand{\scr@ifpdfoutput}{%
  \scr@ifundefined{pdfoutput}{%
    \scr@ifundefined{OpMode}{%
      \expandafter\@secondoftwo%
    }{%
      \ifnum\OpMode=1
        \expandafter\@firstoftwo
      \else
        \expandafter\@secondoftwo
      \fi
    }%
  }{%
    \ifnum\pdfoutput>0 
      \expandafter\@firstoftwo
    \else
      \expandafter\@secondoftwo
    \fi
  }%
}%
\let@as@internal@defined{ifpdfoutput}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\ifpsoutput}
%    \changes{v2.95}{2002/08/21}{neu}
%  \begin{macro}{\scr@ifpsoutput}
%    \changes{v2.95}{2002/08/21}{neu (intern)}
%    \changes{v2.95}{2004/07/20}{Expandierbarkeit verbessert}
% If-then-else-Konstrukt, um abhängig davon, ob früher oder später
% \texttt{ps} ausgegeben wird oder nicht, Befehle auszuführen.
%    \begin{macrocode}
\newcommand*{\scr@ifpsoutput}{%
  \ifnotundefined{if@dvips}{%
    \if@dvips 
      \expandafter\@firstoftwo
    \else 
      \expandafter\@secondoftwo
    \fi
  }{%
    \ifnotundefined{OpMode}{%
      \ifnum\OpMode=2
        \expandafter\@firstoftwo
      \else
        \expandafter\@secondoftwo
      \fi
    }{%
      \expandafter\@secondoftwo
    }%
  }%
}
\let@as@internal@defined{ifpsoutput}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\ifdvioutput}
%    \changes{v2.95}{2002/08/21}{neu}
%  \begin{macro}{\scr@ifdvioutput}
%    \changes{v2.95}{2002/08/21}{neu (intern)}
%    \changes{v2.95}{2004/07/20}{Expandierbarkeit verbessert}
% If-then-else-Konstrukt, um abhängig davon, ob \texttt{dvi}
% ausgegeben wird oder nicht, Befehle auszuführen.
%    \begin{macrocode}
\newcommand*{\scr@ifdvioutput}{%
  \scr@ifundefined{pdfoutput}{%
    \scr@ifundefined{OpMode}{%
      \expandafter\@firstoftwo
    }{%
      \ifnum\OpMode=0
        \expandafter\@firstoftwo
      \else
        \expandafter\@secondoftwo
      \fi
    }%
  }{%
    \ifnum\pdfoutput=0
      \expandafter\@firstoftwo
    \else
      \expandafter\@secondoftwo
    \fi
  }%
}
\let@as@internal@defined{ifdvioutput}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%
% \subsection{Definition von KOMA-\textsf{keyval}-Schlüsseln (Hauptteil)}
%
%  \begin{macro}{\KOMAoptions}
%    \changes{v2.96}{2006/08/20}{Neuer Hook nach den Optionen}
%  \begin{macro}{\post@kopt@hook}
%    \changes{v2.96}{2006/08/20}{Neuer Hook nach den Optionen}
%  \begin{macro}{\AfterKOMAoptions}
%    \changes{v2.96}{2006/08/20}{Neuer Hook nach den Optionen}
% Es werden Schlüssel verwendet und ggf. danach noch Dinge ausgeführt.
%    \begin{macrocode}
\newcommand*{\KOMAoptions}[1]{%
  \let\post@kopt@hook\@empty
  \setkeys{KOMA}{#1}%
  \post@kopt@hook\let\post@kopt@hook\relax
}
\newcommand*{\post@kopt@hook}{}
\let\post@kopt@hook\relax
\newcommand*{\AfterKOMAoptions}{%
  \ifx\post@kopt@hook\relax
    \PackageWarning{scrkbase}{%
      \string\AfterKOMAoptions\space can only be used inside a\MessageBreak
      KOMA-Script option that is called using \space\KOMAoptions.\MessageBreak
      Because if this, command will be ignored%
    }%
    \expandafter\@gobbletwo
  \else
    \expandafter\l@addto@macro
  \fi
  \post@kopt@hook
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{option}{nokey}
% Dies ist in Wirklichkeit kein Schlüssel, sondern eine Fehlermeldung
% für nicht definierte Schlüssel. Er kann jedoch wie ein Schlüssel
% definiert und auch so verwendet werden.
%    \begin{macrocode}
\KOMA@key{nokey}{%
  \PackageError{%
    scrkeyval%
  }{%
    unknown KOMA option `#1'%
  }{%
    You've tried to use the KOMA option `#1'.\MessageBreak 
    But there is no KOMA option with that name.\MessageBreak 
    See the manual of KOMA-Script for information about known KOMA
    options.%
  }%
}%
%    \end{macrocode}
%  \end{option}
%
%  \begin{option}{noval}
% Dies ist in Wirklichkeit kein Schlüssel, sondern eine Fehlermeldung
% für das Fehlen eines Wertes bei der Verwendung eines Schlüssels ohne
% Defaultwert. Er kann jedoch wie ein Schlüssel definiert und auch so
% verwendet werden.
%    \begin{macrocode}
\KOMA@key{noval}{%
  \PackageError{%
    scrkbase%
  }{%
    KOMA option `#1' needs a value%
  }{%
    You've tried to use the KOMA option `#1' without a
    value.\MessageBreak 
    But this option has no default value, so you have to set a
    value.\MessageBreak
    See the manual of KOMA-Script for information about the option and
    all known\MessageBreak
    values.%
  }%
}%
%    \end{macrocode}
%  \end{option}
%
%  \begin{macro}{\KOMA@unknown@keyval}
% Dieses Makro berichtet über Fehler wegen unbekannter Wertübergabe an
% einen Schlüssel. Das erste Argument ist der Schlüssel, das zweite
% der Wert und das dritte die Liste der möglichen Werte.
%    \begin{macrocode}
\newcommand*{\KOMA@unknown@keyval}[3]{%
  \PackageError{%
    scrkbase%
  }{%
    KOMA option `#1' has no value `#2'%
  }{%
    You've tried to set option `#1' to value `#2'.\MessageBreak
    But allowed values are only:\MessageBreak
    #3.\MessageBreak
    See the KOMA-Script manual for more information.%
  }%
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\KOMA@ifkey}
% Dieses Makro definiert einen Schlüssel, der einen Schalter an Hand des
% Wertes setzt. Als Werte sind "`\texttt{true}"', "`\texttt{false}"',
% "`\texttt{on}"', "`\texttt{off}"', "`\texttt{yes}"' und
% "`\texttt{no}"' erlaubt. Der Default-Wert für den Schalter ist
% grundsätzlich "`false"', so dass der Default-Wert für die Verwendung
% des Schküssels grundsätzlich "`true"' ist. Das erste Argument ist
% der Name des Schlüssels, der zweite ist der Name des Schalters. 
%    \begin{macrocode}
\newcommand*{\KOMA@ifkey}[2]{%
  \@ifundefined{if#2}{%
    \expandafter\newif\csname if#2\endcsname
  }{}%
  \KOMA@key{#1}[true]{\KOMA@set@ifkey{#1}{#2}{##1}}%
}
%    \end{macrocode}
%  \begin{macro}{\KOMA@set@ifkey}
% Die eigentliche Arbeit bei der ganzen Sache wird von diesem internen
% Makro erledigt. Dabei wird der Name des Schlüssels zu Argument 1, der
% Name des Schalters zu Argument 2 und der Wert des Schlüssels wird
% Argument 3.
%    \begin{macrocode}
\newcommand*{\KOMA@set@ifkey}[3]{%
  \ifstr{#3}{true}{\@nameuse{#2true}}{%
    \ifstr{#3}{on}{\@nameuse{#2true}}{%
      \ifstr{#3}{yes}{\@nameuse{#2true}}{%
        \ifstr{#3}{false}{\@nameuse{#2false}}{%
          \ifstr{#3}{off}{\@nameuse{#2false}}{%
            \ifstr{#3}{no}{\@nameuse{#2false}}{%
              \KOMA@unknown@keyval{#1}{#3}{%
                `true', `on', `yes', `false', `off', `no'%
              }%
            }%
          }%
        }%
      }%
    }%
  }%
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\KOMA@ncmdkey}
% Ein ähnliches Makro definiert einen Schlüssel, der ein nummerisches
% Makro auf einen bestimmten Wert setzt. Dabei können auch
% verschiedene symbolische Werte auf denselben nummerischen Wert
% abgebildet werden. Das erste Argument ist obligatorisch und der Name
% des Schlüssels. Das zweite Argument ist optional und der Defaultwert
% für den Schlüssel. Das dritte Argument ist obligatorisch und der
% Name des Makros, das definiert werden soll. Der Defaultwert dafür
% ist 0. Das vierte Argument ist obligatorisch und die Liste der
% symbolischen und nummerischen Wert. Die Liste hat die Form: 
% \{\emph{Symbol}\}\{\emph{Wert}\},\{\emph{Symbol}\}\{\emph{Wert}\}\dots
%  \begin{macro}{\KOMA@@ncmdkey}
% Da nicht das erste, sondern das zweite Argument optional ist, wird
% ein Hilfsmakro benötigt.
%    \begin{macrocode}
\newcommand*{\KOMA@ncmdkey}[1]{%
  \@ifnextchar [%]
    {\KOMA@@ncmdkey{#1}}{\KOMA@@ncmdkey{#1}[]}%
}
\newcommand*{\KOMA@@ncmdkey}{}
\def\KOMA@@ncmdkey#1[#2]#3#4{%
  \ifx\relax#2\relax\else
    \@namedef{KV@KOMA@#1@default\expandafter}\expandafter{%
      \csname KV@KOMA@#1\endcsname{#2}%
    }%
  \fi
  \@ifundefined{#3}{\@namedef{#3}{0}}%
  \KOMA@key{#1}{\KOMA@set@ncmdkey{#1}{#3}{#4}{##1}}%
}
%    \end{macrocode}
%  \begin{macro}{\KOMA@set@ncmdkey}
% Die eigentliche Arbeit dabei wird von diesem Makro erledigt. Dabei
% wird der Name des Schlüssels zu Argument 1, der Name des Makros,
% das definiert werden soll zu Argument 2, die Liste zu Argument 3 und
% der Wert, auf den gesetzt werden soll, zu Argument 4.
%    \begin{macrocode}
\newcommand*{\KOMA@set@ncmdkey}[4]{%
  \begingroup
    \edef\@searched{#4}%
    \let\@tempa=\@empty
    \let\@tempb=\@empty
    \@tempswafalse
    \@for\@valuelist:=#3\do{%
      \if@tempswa\else
        \edef\@tempc{\expandafter\@firstoftwo\@valuelist}%
        \edef\@tempa{\@tempa\@tempb`\@tempc'}%
        \edef\@tempb{, }%
        \ifx\@tempc\@searched
          \@tempswatrue
          \edef\@tempa{\expandafter\@secondoftwo\@valuelist}%
        \fi
      \fi
    }%
    \if@tempswa
      \edef\@tempa{\endgroup
        \noexpand\@namedef{#2}{\@tempa}%
      }%
    \else
      \KOMA@unknown@keyval{#1}{#4}{\@tempa}%
      \let\@tempa=\endgroup
    \fi
  \@tempa
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\KOMA@DeclareObsoleteOption}
%    \changes{v2.96}{2006/08/20}{\cs{CurrentOption wir geschützt}}
% Mit Hilfe dieses Makros kann eine Option definiert werden, die
% eigentlich obsolete ist. Statt dieser Option wird dann ein Schlüssel
% verwendet. Das erste Argument ist optional und muss dann entweder
% \cs{PackageInfo}, \cs{PackageInfoNoLine}, \cs{PackageWarning} oder
% \cs{PackageWarningNoLine} sein. Das zweite Argument ist der Name der
% Option. Das dritte Argument ist das Setzen des gewünschten Schlüssels.
%  \begin{macro}{\scr@sr@co}
%    \changes{v2.96}{2006/08/20}{neu (intern)}
% Da das \texttt{xkeyval}-Paket leider \cs{CurrentOption} vernichtet, das aber
% innerhalb von \cs{ProcessOptions} nach dem Ausführen der Option noch
% benötigt wird, muss die Anweisung gesichert werden.
%    \begin{macrocode}
\newcommand*{\scr@sr@co}{}
\newcommand*{\KOMA@DeclareObsoleteOption}[3][\@gobbletwo]{%
  \DeclareOption{#2}{%
    \let\scr@sr@co\CurrentOption
    \KOMA@UseObsolete{option}{#1}{#2}{#3}%
    \let\CurrentOption\scr@sr@co
  }%
}
%    \end{macrocode}
%  \end{macro}
%  \begin{macro}{\KOMA@UseObsolete}
% Die eigentliche Arbeit wird von diesem Makro erledigt. Ob es sich um
% eine Option oder eine Anweisung handelt wird in Argument 1
% übergeben. Alle anderen Argumente schließen sich daran an.
%    \begin{macrocode}
\newcommand*{\KOMA@UseObsolete}[4]{%
  #2{%
    scrkbase%
  }{%
    You've used the obsolete #1 `#3'.\MessageBreak
    \protect\KOMAoptions{#4} will be used instead.\MessageBreak
    You should do this change too%
  }%
  \KOMAoptions{#4}%
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\KOMA@newobsoletecommand}
% Mit Hilfe dieses Makros kann ein Makro definiert werden, das
% eigentlich obsolete ist. Das Makro verwendet dann schlicht einen
% Schlüssel. Das erste Argument ist optional und muss dann entweder
% \cs{PackageInfo}, \cs{PackageInfoNoLine}, \cs{PackageWarning} oder
% \cs{PackageWarningNoLine} sein. Das zweite Argument ist das Makro.
% Das dritte Argument ist das Setzen des gewünschten Schlüssels. Das
% definierte Makro selbst hat Schaltercharakter, ist also nicht
% \cs{long} und versteht auch keine Argumente.
%    \begin{macrocode}
\newcommand*{\KOMA@newobsoletecommand}[3][\@gobbletwo]{%
  \newcommand*{#2}{\KOMA@UseObsolete{command}{#1}{\string#2}{#3}}%
}
%    \end{macrocode}
%  \end{macro}
%
%
% \iffalse
%</body>
% \fi
%
% \Finale
%
\endinput
%
% end of file `scrkbase.dtx'
%%% Local Variables:
%%% mode: doctex
%%% TeX-master: t
%%% End:
