% ======================================================================
% scrlayer.tex
% Copyright (c) Markus Kohm, 2013
%
% This file is part of the LaTeX2e KOMA-Script bundle.
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3c of the license.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3c or later is part of all distributions of LaTeX 
% version 2005/12/01 or later and of this work.
%
% This work has the LPPL maintenance status "author-maintained".
%
% The Current Maintainer and author of this work is Markus Kohm.
%
% This work consists of all files listed in manifest.txt.
% ----------------------------------------------------------------------
% scrlayer.tex
% Copyright (c) Markus Kohm, 2013
%
% Dieses Werk darf nach den Bedingungen der LaTeX Project Public Lizenz,
% Version 1.3c, verteilt und/oder veraendert werden.
% Die neuste Version dieser Lizenz ist
%   http://www.latex-project.org/lppl.txt
% und Version 1.3c ist Teil aller Verteilungen von LaTeX
% Version 2005/12/01 oder spaeter und dieses Werks.
%
% Dieses Werk hat den LPPL-Verwaltungs-Status "author-maintained"
% (allein durch den Autor verwaltet).
%
% Der Aktuelle Verwalter und Autor dieses Werkes ist Markus Kohm.
% 
% Dieses Werk besteht aus den in manifest.txt aufgefuehrten Dateien.
% ======================================================================
%
% Chapter about scrlayer of the KOMA-Script guide
% Maintained by Markus Kohm
%
% ----------------------------------------------------------------------
%
% Kapitel ueber scrlayer in der KOMA-Script-Anleitung
% Verwaltet von Markus Kohm
%
% ============================================================================

\KOMAProvidesFile{scrlayer.tex}
                 [$Date$
                  KOMA-Script guide (chapter:scrlayer)]

\translator{Markus Kohm}

% Date of the translated file: 2013-10-31

\chapter[{Defining Layers and Page Styles Using \Package{scrlayer}}]%
{Defining Layers and Page Styles Using \Package{scrlayer}%
}
\labelbase{scrlayer}

\BeginIndex{Package}{scrlayer}

Most users of graphics software already know layer models for pages or working
sheets. \LaTeX{} itself doesn't know layers, but there are already packages
like \Package{eso-pic} or \Package{textpos}, that provide a kind of
background or foreground layer. \Package{scrlayer} is another package,
that provides such background and foreground layers, but in difference
to the other packages mentioned above these layers are part of the
page style definition. With this you may simply switch between usage
of layers by switching the page style.

To do so, the package also supports a low level interface to define page
styles using a layer stack, to put layers onto a page style's layer stack, to
put layers at the lowest position of a page style's layer stack, to put layers
before or after a layer of a page style's layer stack, to remove a layer from
a page style's layer stack and to remove doublets of layers of a page style's
layer stack. In short words: The page style interface of \Package{scrlayer}
provides commands to define layer-stack-based page styles and to manage those
layer stacks.

Nevertheless using the layers directly is recommended for advanced users only.
End user interfaces for beginners or average users are provided by additional
packages, that load \Package{scrlayer} on their own. See
\autoref{cha:scrlayer-scrpage} in \autoref{par:forAuthors} of this
\iffree{manual}{book}.

\section{State of Development Note}
\label{sec:scrlayer.draft}

Development of this package hasn't been finished yet. Parts of the package are
even still experimental. Because of this,
especially internal functionality may be changed in future. Most likely the
package will be extended. And because of the early state of development, you
should not expect a complete and finished user manual. Nevertheless this
manual, that is recommended for advanced users and developers, shows the
current state of development of those parts of \Package{scrlayer}, that are
released for using. Everything, that hasn't been documented yet, shouldn't be
used for anything else but testing.

\LoadCommon{0} % \section{Early or Late Selection of Options}

\section{Some Generic Information}
\label{sec:scrlayer.generic}

The package needs some generic information about the class. Class authors may
help \Package{scrlayer} setting this information. Otherwise the package tries
to detect the information itself. This works, e.g., for the standard classes
and the \KOMAScript{} classes. But it may or may not fail with other classes.

This section describes some of the information, that class authors may
provide. Generally users need not to care about this.

\begin{Declaration}
  \Macro{if@chapter}\ \PName{then code} \Macro{else}\ \PName{else code}
  \Macro{fi}%
\end{Declaration}
\BeginIndex{Cmd}{if@chapter}%
If \Macro{if@chapter} is defined and \Macro{iftrue}, \Package{scrlayer} will
work including the chapter level, e.g., at option \Option{automark}. If it is
defined, but not \Macro{iftrue}, it only handles part, section, subsection,
sub\dots subsection, paragraph, subparagraph, sub\dots subparagraph. If the
macro isn't defined, \Package{scrlayer} searches for \Macro{chapter}. If
\Macro{chapter} is defined and not \Macro{relax}, \Package{scrlayer} will
define \Macro{if@chapter} to \Macro{iftrue}, otherwise \Macro{if@chapter} will
become \Macro{iffalse}.%
\EndIndex{Cmd}{if@chapter}

\begin{Declaration}
  \Macro{if@mainmatter}\ \PName{then code} \Macro{else}\ \PName{else code}
  \Macro{fi}%
\end{Declaration}
\BeginIndex{Cmd}{if@mainmatter}%
Classes like \Class{book} define \Macro{frontmatter}, \Macro{mainmatter}, and
\Macro{backmatter}. They also use \Macro{if@mainmatter} to distinguish whether
or the current matter is the main matter. Classes like \Class{report} and
\Class{article} don't have \Macro{frontmatter}, \Macro{mainmatter}, or
\Macro{backmatter} and therefore also don't have \Macro{if@mainmatter}.

For \Package{scrlayer} it's easier not to test always for the existence of the
matter commands, but to have \Macro{if@mainmatter} even with classes like
\Class{report} and \Class{article}, simply set to \Macro{iftrue}. So if
\Macro{if@mainmatter} is not defined, it will be defined to \Macro{iftrue}.

Some classes have \Macro{frontmatter}, \Macro{mainmatter}, or
\Macro{backmatter} but not \Macro{if@mainmatter}. In this case
\Package{scrlayer} will also define \Macro{if@mainmatter} to be \Macro{iftrue}
and it'll extend definition of \Macro{frontmatter}, \Macro{mainmatter}, and
\Macro{backmatter} to set \Macro{if@mainmatter} properly. Other matter
commands are not known, not tested, and not extended. So if there other matter
commands \Package{scrlayer} needs help of the class author to get
\Macro{if@mainmatter} set correctly.%
\EndIndex{Cmd}{if@mainmatter}

\begin{Declaration}
  \Macro{DeclareSectionNumberDepth}%^^A
  \Parameter{level name}\Parameter{level depth}
\end{Declaration}
\BeginIndex{Cmd}{DeclareSectionNumberDepth}%
Generally each section level is related to a numerical depth. \LaTeX{} needs
this to manage hierarchic section levels. But normally only the document
class, that defines the section commands, itself knows the numerical depth of
a section level and uses these numerical values inside the corresponding
commands, where they are needed.

But \Package{scrlayer} also needs information about the section hierarchy.
With command \Macro{DeclareSectionNumberDepth} you can map
the name of a heading level to a section numbering depth. With standard class
book, e.g., the \PName{level name} could be \PValue{part}, \PValue{chapter},
\PValue{section}, \PValue{subsection}, \PValue{subsubsection},
\PValue{paragraph}, or \PValue{subparagraph} and the corresponding
\PName{level depth}s would be -1, 0, 1, 2, 3, 4, and 5. 

Package \Package{scrlayer} tries to determine the numeric depth on it's own
while loading and while \Macro{begin}\PParameter{document}. But, if it fails,
i.\,e., if there exist completely different section commands, it would be
useful, to be able to define the relationship explicitly. For such cases
\Macro{DeclareSectionNumberDepth} could be useful.%
\EndIndex{Cmd}{DeclareSectionNumberDepth}

\section{Declaration of Layers}
\label{sec:scrlayer.layers}

A layer is a kind of logical sheet of transparent paper (in opposite to a
physical sheet of paper). One layer is stacked onto another layer and opaque
material on one layer may hide material on the layers below. The stack of all
layers together makes the physical page. Package \Package{scrlayer}
provides two such layer stacks for each page: a background layer stack and a
foreground layer stack. The background layer stack is behind the normal page
contents, the foreground layer stack is above the normal page contents. So the
normal contents is a kind of a separating layer.

A layer has several attributes. The first attribute is, whether or not
the layer is part of the foreground or the background. Background
layers will be printed before the main contents of the page. Optically
they will be behind the main contents. Foreground layers will be
printed after the main contents of the page. Optically they will be in
front of the main contents. By default, a layer is both, a background
layer \emph{and} a foreground layer and therefore will be printed
twice.

The second and third attributes are the horizontal and vertical position of
the layer. The forth and fifth attributes are the horizontal and vertical size
of the layer. As you can see, a layer may be smaller or larger than the
paper.

But how are the horizontal an vertical positions measured? The answer
is the sixth attribute, the alignment. We can measure from the left edge of
the paper to the left edge of the layer, or from the left edge of the paper to
the middle of the layer, or from the left edge of the paper to the right edge
of the layer. We can measure from the top edge of the paper to the top edge of
the layer, or to the middle of the layer, or to the bottom edge of the layer.

The seventh attribute is, whether or not a layer should be
printed onto left or right pages. By default a layer will be printed at both,
left and right pages. Note, that \LaTeX{} names left pages as even pages and
right pages as odd pages and that there are no left or even pages in
single-sided mode.

The eighth attribute is, whether or not a layer should be printed in
single-side mode or in two-side mode. By default a layer will be printed in
both, single-side mode and two-side mode. Nevertheless an even page layer will
never be printed in single-side mode and therefore isn't really a two-side
mode layer.

The ninth attribute is, whether or not a layer should be
printed onto float pages or non-float pages. \LaTeX{} produces float pages for
float environment like tables or figures, if they are allowed to be printed on
a page without normal page contents (see option \PValue{p} for
\Environment{figure} or \Environment{table}). So in some kind of view a float
page is a page, that may flow at whole. Non-float pages aren't pages
without floats, but pages, that aren't float pages. They may contain floats
inside the text, on the top of the page, or on the bottom of the page. Very
large floats may seem to be page floats, while in reality they are top floats.

The tenth and last attribute is the contents of the layer. This is simply,
what should be printed, whenever the layer will be printed.

So we have ten attributes yet. Below in this manual we will see additional
attributes, that may be build by these ten attribute. Because of this, we
call these twelve attributes the primary attributes.

\begin{Declaration}
  \Macro{DeclareLayer}\OParameter{option list}\Parameter{layer name}\\
  \Macro{DeclareNewLayer}\OParameter{option list}\Parameter{layer name}\\
  \Macro{ProvideLayer}\OParameter{option list}\Parameter{layer name}\\
  \Macro{RedeclareLayer}\OParameter{option list}\Parameter{layer name}\\
  \Macro{ModifyLayer}\OParameter{option list}\Parameter{layer name}
\end{Declaration}
\BeginIndex{Cmd}{DeclareLayer}%
\BeginIndex{Cmd}{DeclareNewLayer}%
\BeginIndex{Cmd}{ProvideLayer}%
\BeginIndex{Cmd}{RedeclareLayer}%
\BeginIndex{Cmd}{ModifyLayer}%
These commands can be used to define a layer. The \PName{layer name} has to be
fully expandable and should expand to letters only. Some additional characters
would be tolerated but aren't recommended.

Command \Macro{DeclareLayer} doesn't care whether or not a layer with the
given \PName{layer name} already exists. It will under all circumstances
define the layer with the attribute defined by the \PName{option list}.
An
\PName{option} may be either a key or a key followed by an
equal sign followed by a value. Several options may be concatenated to
a \PName{option list} and have to be separated by comma. If you'd like to have
a comma or a white space inside the value of an option, you should put the
value inside curly brackets. See \autoref{tab:scrlayer.layerkeys} for
more information about the names of the key and the corresponding
attributes.

The difference between \Macro{DeclareLayer} and \Macro{DeclareNewLayer} is,
that using \Macro{DeclareNewLayer} would result in an error, if a layer with
the same \PName{layer name} already exists. So you may prevent yourself using
the same \PName{layer name} more than once by mistake. This would be useful,
e.\,g., if a class or package also defines layers internally.

The difference between \Macro{DeclareLayer} and \Macro{ProvideLayer} is, that
using \Macro{ProvideLayer} would be simply ignored, if a layer with the same
\PName{layer name} already exists. So it is something like: \emph{declare the
  layer only, if is hasn't been declared already.}

If an existing layer should be redefined, \Macro{RedeclareLayer} or
\Macro{ModifyLayer} can be used. \Macro{RedeclareLayer} would simply define
the layer as if it would be defined newly. In difference to this,
\Macro{ModifyLayer} would change only those attributes, that are represented
by an option of the \PName{option list}. All other attributes stay unchanged
and won't be reset to the initial default state. Using either
\Macro{RedeclareLayer} or \Macro{ModifyLayer} with a \PName{layer name}, that
isn't the name of an already defined layer, will result in an error.

\begin{desclist}
  \desccaption{%
    Options for the definition of page layers with description of the
    corresponding layer attribute\label{tab:scrlayer.layerkeys}%
  }{%
    Options for the definition of layers (\emph{Continuation})%
  }%
  \nentry{\KOption{align}{\PName{alignment characters}}}{%
    The \PName{alignment characters} define the wanted alignment of the
    layer. Each \PName{alignment character} influences either, how argument
    \PName{length} of option \Option{hoffset} or \Option{voffset} will be
    used. Several \PName{alignment characters} may be used together (without
    comma or space) and will be interpreted in the order of occurrence. No
    macros should be used here! Valid \PName{alignment character}s are:
    \begin{description}
    \item[\PValue{b} --] align the layer with its bottom edge to the given
      \Option{length} of \Option{voffset} from the top edge of the paper.
    \item[\PValue{c} --] align the layer with its centre to the given
      \PValue{length} of \Option{hoffset} from the left edge and of
      \Option{voffset} from the top edge of the paper.
    \item[\PValue{l} --] align the layer with its left edge to the given
      \PValue{length} of \Option{hoffset} from the left edge of the paper.
    \item[\PValue{r} --] align the layer with its right edge to the given
      \PValue{length} of \Option{hoffset} from the left edge of the paper.
    \item[\PValue{t} --] align the layer with its top edge to the given
      \Option{length} of \Option{voffset} from the top edge of the paper.
    \end{description}%
  }%
  \nentry{\KOption{area}{%^^A
      \Parameter{hoffset}\Parameter{voffset}%^^A
      \Parameter{width}\Parameter{height}}}{%
    The composing option results in \OptionValue{hoffset}{\PName{hoffset}},
    \OptionValue{voffset}{\PName{voffset}},
    \OptionValue{width}{\PName{width}}, \OptionValue{height}{\PName{height}}.%
  }%
  \entry{\Option{background}}{%
    Print the layer only in the background, but not in the foreground. This
    makes a background-only layer in opposite to the default of layers which
    are both, background and foreground layers and therefore would be printed
    twice. The option doesn't expect any value. By the default the attribute
    is not set.%
  }%
  \entry{\Option{bottommargin}}{%
    The composing option sets \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, and \Option{align} to horizontally span
    the paper from the left edge to the right and vertically span the area
    below the footer down to the bottom edge of the paper.%
  }%
  \nentry{\KOption{clone}{\PName{layer name}}}{%
    The composing option sets all primary attributes of the layer to the same
    values as the primary attributes of the layer with the given \PName{layer
      name}. Note, that \PName{layer name} has to be fully expandable and
    should expand to letters only. Some additional characters will be
    tolerated, but they are not recommended!%
  }%
  \nentry{\KOption{contents}{\PName{code}}}{%
    The \PName{code} will be expanded whenever the layer is printed. So the
    \PName{code} is what you will see. No checks for valid code will be
    done. So errors in \PName{code} may result in several failures on each
    page, that prints the layer.%
  }%
  \entry{\Option{evenpage}}{%
    Print the layer on even pages only, but not on odd pages. The option
    doesn't expect any value. By the default the option is not set and
    therefore layers would be printed on odd pages and on even pages. Note,
    that this attribute includes \Option{twoside}.%
  }%
  \entry{\Option{floatpage}}{%
    Print the layer on float pages only, but not on other pages. The option
    doesn't expect any value. By the default the attribute is not set and
    therefore layers would be printed on float pages and on non-float pages.%
  }%
  \entry{\Option{foot}}{%
    The composing option sets \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, and \Option{align} to horizontally span
    the text area and vertically span the page footer defined by the new
    \LaTeX{} length \Length{footheight}.%
  }%
  \entry{\Option{footskip}}{%
    The composing option sets \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, and \Option{align} to horizontally span
    the text area and vertically span the distance between the text area and
    the page footer (note, that this is not the same like \Length{footskip}).%
  }%
  \entry{\Option{foreground}}{%
    Print the layer only in the foreground, but not in the background. This
    makes a foreground-only layer in opposite to the default of layers which
    are both, background and foreground layers and therefore would be printed
    twice. The option doesn't expect any value. By the default the attribute
    is not set.%
  }%
  \entry{\Option{head}}{%
    The composing option sets \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, and \Option{align} to horizontally span
    the text area and vertically span the page head defined by usual\LaTeX{}
    length \Length{headheight}.%
  }%
  \entry{\Option{headsep}}{%
    The composing option sets \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, and \Option{align} to horizontally span
    the text area and vertically span the distance between the page head and
    the text area.%
  }%
  \nentry{\KOption{height}{\PName{length}}}{%
    Sets the height of the layer. Note, that \PName{length} may either a
    \LaTeX{} length, declared using \Macro{newlength}, or a \TeX{} length,
    declared using \Macro{newdimen} or \Macro{newskip}, a length value like
    10\,pt, or a dimensional expression using +, -, /, *, (, and ). For more
    information about valid dimensional expression see
    \cite[section~3.5]{manual:eTeX}.%
  }%
  \nentry{\KOption{hoffset}{\PName{length}}}{%
    Sets the offset of the layer (depending on \Option{align} either left edge
    of the layer, middle of the layer or right edge of the layer) from the
    left edge of the paper. See \Option{height} for more information about
    valid content of \PName{length}.%
  }%
  \entry{\Option{innermargin}}{%
    The composing option sets \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, and \Option{align} to horizontally span
    the distance between the right edge of text area and the right edge of the
    paper on even pages or the distance between the left edge of the paper and
    the left edge of the text area on odd pages and vertically span the whole
    paper from the top edge to the bottom edge.%
  }%
  \entry{\Option{leftmargin}}{%
    The composing option sets \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, and \Option{align} to horizontally span
    the distance between the left edge of the paper and the left edge of the
    text area and vertically span the whole paper from the top edge to the
    bottom edge.%
  }%
  \entry{\Option{nonfloatpage}}{%
    Restricts the layer to pages, that aren't float pages. The option doesn't
    expect any value. By the default the attribute is not set and therefore
    layers would be printed on float pages and on non-float pages.%
  }%
  \entry{\Option{oddpage}}{%
    Print the layer on odd pages only, but not on even pages. The option
    doesn't expect any value. By the default the option is not set and
    therefore layers would be printed on odd pages and on even pages.%
  }%
  \entry{\Option{oneside}}{%
    Print the layer in single-side mode only, but not in two-side mode. The
    option doesn't expect any value. By the default the attribute is not set
    and therefore layers would be printed in single-side and two-side mode.%
  }%
  \entry{\Option{outermargin}}{%
    The composing option sets \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, and \Option{align} to horizontally span
    the distance between the left edge of the paper and the left edge of the
    text area on even pages or the distance between the right edge of the text
    area and the right edge of the paper on odd pages and vertically span the
    whole paper from the top edge to the bottom edge.%
  }%
  \entry{\Option{page}}{%
    The composing option sets \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, and \Option{align} to horizontally and
    vertically span the whole paper from the left edge to the right edge and
    the top edge to the bottom edge.%
  }%
  \entry{\Option{rightmargin}}{%
    The composing option sets \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, and \Option{align} to horizontally span
    the distance between the right edge of text area and the right edge of the
    paper and vertically span the whole paper from the top edge to the bottom
    edge.%
  }%
  \entry{\Option{textarea}}{%
    The composing option sets \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, and \Option{align} to horizontally and
    vertically span the whole text area from the left edge to the right edge
    and the top edge to the bottom edge.%
  }%
  \entry{\Option{topmargin}}{%
    The composing option sets \Option{hoffset}, \Option{voffset},
    \Option{width}, \Option{height}, and \Option{align} to horizontally span
    the whole page from the left edge to the right edge and vertically span
    the distance between the top edge of the paper and the page head.%
  }%
  \entry{\Option{twoside}}{%
    Print the layer in two-side mode only, but not in single-side mode. The
    option doesn't expect any value. By the default the attribute is not set
    and therefore layers would be printed in single-side and two-side mode.%
  }%
  \nentry{\KOption{voffset}{\PName{length}}}{%
    Sets the offset of the layer (depending on \Option{align} either top edge
    of the layer, middle of the layer or bottom edge of the layer) from the
    top edge of the paper. See \Option{height} for more information about
    valid content of \PName{length}.%
  }%
  \nentry{\KOption{width}{\PName{length}}}{%
    Sets the width of the layer. See \Option{height} for more information
    about valid content of \PName{length}.%
  }%
\end{desclist}
%
\EndIndex{Cmd}{ModifyLayer}%
\EndIndex{Cmd}{RedeclareLayer}%
\EndIndex{Cmd}{ProvideLayer}%
\EndIndex{Cmd}{DeclareNewLayer}%
\EndIndex{Cmd}{DeclareLayer}%

\begin{Declaration}
  \Macro{layerxoffset}\\
  \Macro{layeryoffset}\\
  \Macro{layerwidth}\\
  \Macro{layerheight}%
\end{Declaration}
\BeginIndex{Cmd}{layerxoffset}%
\BeginIndex{Cmd}{layeryoffset}%
\BeginIndex{Cmd}{layerwidth}%
\BeginIndex{Cmd}{layerheight}%
These commands are valid while output of the layer contents. So they may be used
inside the \PName{code} of option \Option{contents} of the previously
described commands only. In this case they give the effective position and
dimension of the layer, that will be used for the output. This is indeed not
the effective dimension of the layer's contents, i.\,e., if the contents are
oversized or don't fill the layer completely. Redefinition of the commands to
change the stored values is strictly forbidden and would result in
unpredictable issues.%
\EndIndex{Cmd}{layerheight}%
\EndIndex{Cmd}{layerwidth}%
\EndIndex{Cmd}{layeryoffset}%
\EndIndex{Cmd}{layerxoffset}%

\begin{Declaration}
  \Macro{IfLayerExists}%
  \Parameter{string}\Parameter{then-code}\Parameter{else-code}
\end{Declaration}
\BeginIndex{Cmd}{IfLayerExists}%
This command may be used to execute code depending on whether or not a layer
has been defined already. If the layer exists \PName{then-code} will be
executed, otherwise \PName{else-code}. Note, that the command cannot really
test whether a layer exists. It uses a heuristic, that will never be false
negative, but may be false positive. Nevertheless, if it is false positive
something went wrong, either an incompatible package has been used or the user
made something he shouldn't do.%
\EndIndex{Cmd}{IfLayerExists}

\begin{Declaration}
  \Macro{DestroyLayer}\Parameter{layer name}
\end{Declaration}
\BeginIndex{Cmd}{DestroyLayer}%
This command sets all macros corresponding with the layer with given
\PName{layer name} to \Macro{relax}, if a layer with that name exists. After
this the layer may not be used any longer. But it doesn't matter, if the layer
is still part of the layer list of a page style, because such destroyed layers
will be ignored. Nevertheless destroyed layers may be defined newly using
\Macro{DeclareNewLayer} or \Macro{ProvideLayer}, but couldn't be changed using
\Macro{RedeclareLayer} or \Macro{ModifyLayer} any longer. 

The command is intended to be used inside
\Macro{scrlayerOnAutoRemoveInterface} to remove layers, that have been defined
using removable macros of an interface, whenever the interface would be
removed.%
\EndIndex{Cmd}{DestroyLayer}

\begin{Declaration}
  \Macro{layercontentsmeasure}\\
\end{Declaration}
\BeginIndex{Cmd}{layercontentsmeasure}%
The command \Macro{layercontentsmeasure} is internally used, if option
\Option{draft} has been set, so visualise the layers. The visualisation will
be done with a centimetre ruler at the top and left edge of the layer and an
inch ruler at the bottom and right edge of the layer. The rulers will be drawn
behind the content of the layer. If you would, you could also use it as
exclusive content of a layer.%
\EndIndex{Cmd}{layercontentsmeasure}


\section{Declaration and Management of Page Styles}
\label{sec:scrlayer.pagestyles}

Until now we know layers, but we don't know how to use them. The
perhaps astonishing answer is: with page styles. In \LaTeX{}, page
styles usually define heads and foots of odd and even pages.

The head and foot of odd pages will be printed on pages with odd
page number in two-side mode or on all pages in single-side mode. This is
something like the layer attributes \Option{oddpage} and \Option{evenpage}.

The page head will be printed before the main contents of a page. The page
footer will be printed after the main contents of a page. So this is something
like the layer attributes \Option{background} and \Option{foreground}.

So it's obvious to declare page styles to be a list of layers. But instead of
having only four attributes \Option{oddpage}, \Option{evenpage},
\Option{background}, and \Option{foreground} all the attributes of layers
shown in \autoref{sec:scrlayer.layers} may be used.

The outcome of this is, that one kind of page styles \Package{scrlayer}
provides are layer page styles. A layer page style consists of layers and
several \emph{hooks}. For description of layers see
\autoref{sec:scrlayer.layers}.  The \emph{hooks} are points in the expansion
or execution of page styles and you may add additional code, that will be
expanded there. Advanced users know this already from commands like
\Macro{AtBeginDocument} (see \cite{latex:usrguide}) or
\Macro{BeforeClosingMainAux} (see
\autopageref{desc:scrlfile.cmd.BeforeClosingMainAux}).

Another kind of page styles, that \Package{scrlayer} provides, are alias page
style. An alias page style simply consists of another page style. In other
words, the name of an alias page style is an alias name of another page
style, the aliased or original page style. Because of this, the manipulation
of an alias page style results in the manipulation of the original page
style. If the original page style is an alias page style too, the manipulation
will result in the manipulation of the aliased page style of that original
page style and so on until a real page style will be manipulated. You may not
only alias layer page styles made with \Package{scrlayer}, but all kind of
page styles.

\begin{Declaration}
  \Macro{currentpagestyle}
\end{Declaration}
\BeginIndex{Cmd}{currentpagestyle}%
Package scrlayer patches \Macro{pagestyle} to set \Macro{currentpagestyle} to
the currently active page style. Note, that \Macro{thispagestyle} does not
change \Macro{currentpagestyle}. But if you use \Macro{thispagestyle} the
result of \Macro{currentpagestyle} may be changed while execution of the
\LaTeX{} output routine. This may be relevant only, if
\Macro{currentpagestyle} has been used protected until execution of the output
routine.

Note, that the layer page styles described later in this section, won't need
the patch of \Macro{pagestyle} to set \Macro{currentpagestyle}. The patch has
been made for usage with other page styles. Note also, that
\Macro{currentpagestyle} is empty before the first \Macro{pagestyle} after
loading \Package{scrlayer}. So if you define an end user page style interface,
it may be useful to use an implicit \Macro{pagestyle} to set the current page
style to a default page style.%
\EndIndex{Cmd}{currentpagestyle}

\begin{Declaration}
  \Macro{BeforeSelectAnyPageStyle}\Parameter{code}\\
  \Macro{AfterSelectAnyPageStyle}\Parameter{code}%^^A
\end{Declaration}
\BeginIndex{Cmd}{BeforeSelectAnyPageStyle}%
\BeginIndex{Cmd}{AfterSelectAnyPageStyle}%
The command \Macro{BeforeSelectAnyPageStyle} adds \PName{code} to hook, that
will be executed inside of \Macro{pagestyle} just before the page style will
be selected. You may use \texttt{\#1} as a placeholder for the argument of
\Macro{pagestyle}.

The command \Macro{AfterSelectAnyPageStyle} is similar, but the \PName{code}
will be executed just after the page style has been selected and after
\Macro{currentpagestyle} has been set to the name of real page style.

Note\textnote{Attention!}, that \PName{code} of both commands will be executed
only, if a page style will be selected using \Macro{pagestyle}, but not,
e.\,g., if a page style will be selected using \Macro{thispagestyle}. Note
also, that you cannot remove \PName{code} from the hook after adding it. But
the \PName{code} will be added locally, so you may use a group to limit the
scope of \PName{code}.%^^A
\EndIndex{Cmd}{AfterSelectAnyPageStyle}
\EndIndex{Cmd}{BeforeSelectAnyPageStyle}

\begin{Declaration}
  \Macro{DeclarePageStyleAlias}%
  \Parameter{alias page style name}\Parameter{original page style name}\\
  \Macro{DeclareNewPageStyleAlias}%
  \Parameter{alias page style name}\Parameter{original page style name}\\
  \Macro{ProvidePageStyleAlias}%
  \Parameter{alias page style name}\Parameter{original page style name}\\
  \Macro{RedeclarePageStyleAlias}%
  \Parameter{alias page style name}\Parameter{original page style name}
\end{Declaration}
\BeginIndex{Cmd}{DeclarePageStyleAlias}%
\BeginIndex{Cmd}{DeclareNewPageStyleAlias}%
\BeginIndex{Cmd}{ProvidePageStyleAlias}%
\BeginIndex{Cmd}{RedeclarePageStyleAlias}%
These Commands may be used to define a page style with name \PName{alias page
  style name}, that is simply an alias for already existing page style with
name \PName{original page style name}. If there's already a page style
\PName{alias page style name} it will be destroyed before creating the alias
using \Macro{DeclarePageStyleAlias} or \Macro{RedeclarePageStyleAlias}.

\Macro{DeclareNewPageStyleAlias} will throw an error message, if a page style
\PName{alias page style name} has already been defined before. It doesn't
matter if the already defined page style is a layer page style, an alias page
style or another page style.

\Macro{ProvidePageStyleAlias} will define the alias only, if a page style
\PName{alias page style name} hasn't been defined before. If a page style
\PName{alias page style name} already exists nothing will be done.

\Macro{RedeclarePageStyleAlias} expects, that a page style \PName{alias page
  style name} already exists. In this case it will destroy it and define the
alias newly. In the other case you'll get an error.%
\EndIndex{Cmd}{RedeclarePageStyleAlias}%
\EndIndex{Cmd}{ProvidePageStyleAlias}%
\EndIndex{Cmd}{DeclareNewPageStyleAlias}%
\EndIndex{Cmd}{DeclarePageStyleAlias}

\begin{Declaration}
  \Macro{DestroyPageStyleAlias}\Parameter{page style name}%
\end{Declaration}
\BeginIndex{Cmd}{DestroyPageStyleAlias}%
This command makes the page style with given \PName{page style name}
\LaTeX-undefined, if it is an alias for another page style. After this, the
page style may be defined newly with, e.g., \Macro{DeclareNewAliasPageStyle}
or \Macro{ProvideAliasPageStyle}. 

The command is intended to be used inside of
\Macro{scrlayerOnAutoRemoveInterface} to remove page styles, that have been
declared by an interface and uses removable macros of that interface.%
\EndIndex{Cmd}{DestroyPageStyleAlias}

\begin{Declaration}
  \Macro{GetRealPageStyle}\Parameter{page style name}%
\end{Declaration}
\BeginIndex{Cmd}{GetRealPageStyle}%
The command will result in the (recursive) real page name of the page style,
if the page style with given name \PName{page style name} is an alias of
another page style. In all other cases, even if there's no alias and no page
style named \PName{page style name}, the result would be simply \PName{page
  style name}. The command is fully expandable and may be used, e.g., in the
second argument of \Macro{edef}.%
\EndIndex{Cmd}{GetRealPageStyle}

\begin{Declaration}
  \Macro{DeclarePageStyleByLayers}%
  \OParameter{option list}\Parameter{page style name}\Parameter{layer list}\\
  \Macro{DeclareNewPageStyleByLayers}%
  \OParameter{option list}\Parameter{page style name}\Parameter{layer list}\\
  \Macro{ProvidePageStyleByLayers}%
  \OParameter{option list}\Parameter{page style name}\Parameter{layer list}\\
  \Macro{RedeclarePageStyleByLayers}%^
  \OParameter{option list}\Parameter{page style name}\Parameter{layer list}%
\end{Declaration}
\BeginIndex{Cmd}{DeclarePageStyleByLayers}%
\BeginIndex{Cmd}{DeclareNewPageStyleByLayers}%
\BeginIndex{Cmd}{ProvidePageStyleByLayers}%
\BeginIndex{Cmd}{RedeclarePageStyleByLayers}%
These commands declares a page style with \PName{page style name}. The page
style will consist of the layers given in \PName{layer list}, a comma
separated list of layer names. Note, that the \PName{page style name} and the
layer names at the \PName{layer list} must be fully expandable and should
expand to letters. Several other characters will be tolerated, but
nevertheless, they aren't recommended.

The \PName{option list} is a comma separated list of
\OptionValue{\PName{key}}{\PName{value}} options. These options may be used to
set additional features. Currently they are used to set the code, that should
be expanded or executed at several \emph{hooks}. See the introduction to this
section for more general information about \emph{hooks}. See
\autoref{tab:scrlayer.pagestyle.hooks} for more information about the hooks
and their purpose.

\begin{desclist}
  \desccaption{%
    The \emph{hook} options for page styles (in order of
    execution)\label{tab:scrlayer.pagestyle.hooks}%
  }{%
    The \emph{hook} options for page styles (\emph{Continuation})%
  }%
  \entry{\KOption{onselect}\PName{code}}{%
    Execute \PName{code} whenever the page style will be selected using, e.g.,
    \Macro{pagestyle}. Note\textnote{Attention!}, that \Macro{thispagestyle}
    doesn't select the page style immediately, but asynchronously inside
    \LaTeX's output routine.%
  }%
  \entry{\KOption{oninit}\PName{code}}{%
    Execute \PName{code} whenever the output of the layers of a page style
    will be initialised. Note\textnote{Attention!}, that this will be done
    twice for every page: once for background layers and once for foreground
    layers.%
  }%
  \entry{\KOption{ononeside}\PName{code}}{%
    Execute \PName{code} whenever the output of the layers of a page style in
    single-side mode will initialised.  Note\textnote{Attention!}, that this
    will be done twice for every page: once for background layers and once for
    foreground layers.%
  }%
  \entry{\KOption{ontwoside}\PName{code}}{%
    Execute \PName{code} whenever the output of the layers of a page style in
    two-side mode will initialised.  Note\textnote{Attention!}, that this will
    be done twice for every page: once for background layers and once for
    foreground layers.%
  }%
  \entry{\KOption{onoddpage}\PName{code}}{%
    Execute \PName{code} whenever the output of the layers of a page style on
    an odd page will initialised. Note\textnote{Attention!}, that this will be
    done twice for every page: once for background layers and once for
    foreground layers. Note\textnote{Attention!} also, that in single-side
    mode all pages are odd pages, not only pages with odd page numbers.%
  }%
  \entry{\KOption{onevenpage}\PName{code}}{%
    Execute \PName{code} whenever the output of the layers of a page style on
    an even page will initialised. Note\textnote{Attention!}, that this will
    be done twice for every page: once for background layers and once for
    foreground layers. Note\textnote{Attention!} also, that there aren't even
    pages in single-side mode, but all pages are odd pages, not only pages
    with odd page numbers.%
  }%
  \entry{\KOption{onfloatpage}\PName{code}}{%
    Execute \PName{code} whenever the output of the layers of a page style on
    a float page will initialised. Note\textnote{Attention!}, that this will
    be done twice for every page: once for background layers and once for
    foreground layers. Note\textnote{Attention!} also, that float pages are
    only those pages with p-placed floating objects.%
  }%
  \entry{\KOption{onnonfloatpage}\PName{code}}{%
    Execute \PName{code} whenever the output of the layers of a page style on
    a non-float page will initialised. Note\textnote{Attention!}, that this
    will be done twice for every page: once for background layers and once for
    foreground layers. Note\textnote{Attention!} also, that non-float pages
    are all pages, that aren't float-pages. Those pages may have t-placed,
    h-placed, b-placed, or no floating objects.%
  }%
  \entry{\KOption{onbackground}\PName{code}}{%
    Execute \PName{code} whenever the output of the layers of a page style in
    the background of a page will initialised. Note\textnote{Attention!}, that
    this will be done once for every page.%
  }%
  \entry{\KOption{onforeground}\PName{code}}{%
    Execute \PName{code} whenever the output of the layers of a page style in
    the foreground of a page will initialised. Note\textnote{Attention!}, that
    this will be done once for every page.%
  }%
\end{desclist}

The difference of \Macro{DeclarePageStyleByLayers} and
\Macro{DeclareNewPageStyleByLayers} is, that \Macro{DeclareNewPageStyleByLayers}
will result in an error, if a page style with name \PName{page style name}
already exists. Note, that declaring a page style, that is an alias of another
page style (see \Macro{DeclareAliasPageStyle} prior in this section), will not
re-declare the page style itself, but it's real page style (see
\Macro{GetRealPageStyle} prior in this section).

The difference of \Macro{DeclarePageStyleByLayers} and
\Macro{ProvidePageStyleByLayers} is, that \Macro{ProvidePageStyleByLayers}
will simply do nothing, if there's already a page style with name \PName{page
  style name}. In difference to \Macro{DeclareNewPageStyleByLayers} it won't
raise an error in this case.

The difference of \Macro{DeclarePageStyleByLayers} and
\Macro{RedeclarePageStyleByLayers} is, that \Macro{RedeclarePageStyleByLayers}
may be used only, if the real page style of \PName{page style name} already
exists. Otherwise an error would occur.

Please have also a look at the notes to following pseudo page style
\Pagestyle{@everystyle@}.%
\EndIndex{Cmd}{RedeclarePageStyleByLayers}%
\EndIndex{Cmd}{ProvidePageStyleByLayers}%
\EndIndex{Cmd}{DeclareNewPageStyleByLayers}%
\EndIndex{Cmd}{DeclarePageStyleByLayers}%

\begin{Declaration}
  \Pagestyle{@everystyle@}\\
  \Pagestyle{empty}
\end{Declaration}
\BeginIndex{Pagestyle}{@everysel@}%
\BeginIndex{Pagestyle}{empty}%
There are two somehow special, default layer page styles. The first one is
\Pagestyle{@everystyle@}. This page style shouldn't be used normally, but the
layers of this page style will be used by all the other layer page styles. So
adding a layer to this page style would be similar to adding this layer to all
other layer page styles even the empty one. There's one difference: Layer
referencing commands of the page style interface like
\Macro{ForEachLayerOfPageStyle}, \Macro{AddLayerToPageStyleBeforeLayer}, or
\Macro{AddLayerToPageStyleAfterLayer} ignore the layers of
\Pagestyle{@everystyle@} if they are used for another layer page style.

The other somehow special page style is \Pagestyle{empty}. Normally page style
\Pagestyle{empty} is defined by the \LaTeX{} kernel, to be a page style
without page head or page foot. Package{scrlayer} re-defines it to be a layer
page style without any layer. Nevertheless you may use it like every other
layer page style too. The main advantage above the \LaTeX{} kernel's empty
page style is, that it also executes the layers of special layer page style
\Pagestyle{@everysel@}.%
\EndIndex{Pagestyle}{empty}%
\EndIndex{Pagestyle}{@everysel@}%

\begin{Declaration}
  \KOption{onpsselect}\PValue{code}\\
  \KOption{onpsinit}\PValue{code}\\
  \KOption{onpsoneside}\PValue{code}\\
  \KOption{onpstwoside}\PValue{code}\\
  \KOption{onpsoddpage}\PValue{code}\\
  \KOption{onpsevenpage}\PValue{code}\\
  \KOption{onpsfloatpage}\PValue{code}\\
  \KOption{onpsnonfloatpage}\PValue{code}\\
  \KOption{onpsbackground}\PValue{code}\\
  \KOption{onpsforeground}\PValue{code}
\end{Declaration}
\BeginIndex{Option}{onpsselect~=\PName{code}}%
\BeginIndex{Option}{onpsinit~=\PName{code}}%
\BeginIndex{Option}{onpsoneside~=\PName{code}}%
\BeginIndex{Option}{onpstwoside~=\PName{code}}%
\BeginIndex{Option}{onpsoddpage~=\PName{code}}%
\BeginIndex{Option}{onpsevenpage~=\PName{code}}%
\BeginIndex{Option}{onpsfloatpage~=\PName{code}}%
\BeginIndex{Option}{onpsnonfloatpage~=\PName{code}}%
\BeginIndex{Option}{onpsbackground~=\PName{code}}%
\BeginIndex{Option}{onpsforeground~=\PName{code}}%
There's also a \KOMAScript{} option for each of those \texttt{hooks}. The
names of the \KOMAScript{} options are similar to the names of the page style
options, but with ``\texttt{ps}'' inserted behind ``\texttt{on}''. The value of
the \KOMAScript{} options are the initial defaults of the corresponding
\texttt{hooks}. This default will be extended by every usage of the page style
options at the \PName{option list}. You may remove the default, using
\Macro{ModifyLayerPageStyleOptions} described later in this section.%
\EndIndex{Option}{onpsforeground~=\PName{code}}%
\EndIndex{Option}{onpsbackground~=\PName{code}}%
\EndIndex{Option}{onpsnonfloatpage~=\PName{code}}%
\EndIndex{Option}{onpsfloatpage~=\PName{code}}%
\EndIndex{Option}{onpsevenpage~=\PName{code}}%
\EndIndex{Option}{onpsoddpage~=\PName{code}}%
\EndIndex{Option}{onpstwoside~=\PName{code}}%
\EndIndex{Option}{onpsoneside~=\PName{code}}%
\EndIndex{Option}{onpsinit~=\PName{code}}%
\EndIndex{Option}{onpsselect~=\PName{code}}%

\begin{Declaration}
  \KOption{deactivatepagestylelayers}\PName{simple switch}\\
  \Macro{ForEachLayerOfPageStyle}\Parameter{page style name}\Parameter{code}
\end{Declaration}
\BeginIndex{Cmd}{ForEachLayerOfPageStyle}%
As long as \KOMAScript{} option \Option{deactivatepagestylelayers} hasn't been
activated command \Macro{ForEachLayerOfPageStyle} can be used to process
\PName{code} for every layer, that is a member of the layers list of a page
style with given \PName{page style name}. Inside of \PName{code} the place
holder \PValue{\#1} may be used for the name of the current layer.
\begin{Example}
  If you want to output the names of all layers of page style
  \PValue{scrheadings}, you may us:
\begin{lstcode}
  \let\commaatlist\empty
  \ForEachLayerOfPageStyle{scrheadings}{%
    \commaatlist#1\gdef\commaatlist{, }}
\end{lstcode}
\end{Example}
Usage of \Macro{gdef} instead of \Macro{def} is necessary in the example
above, because \Macro{ForEachLayerOfPageStyle} executes the \PName{code}
inside of a group to minimise side effects. Here \Macro{gdef} redefines
\Macro{commaatlist} globally, so it would be still valid at the execution of
\PName{code} for the next layer.

Several other commands of \Package{scrlayer} also
uses \Macro{ForEachLayerOfPageStyle} internally. So these also won't process
any layer if \KOMAScript{} option \Option{deactivatepagestylelayers} would be
activated. So you may use this options, e.g., to hide all layers of all layer
page styles.%
\EndIndex{Cmd}{ForEachLayerOfPageStyle}%

\begin{Declaration}
  \Macro{AddLayersToPageStyle}%
  \Parameter{page style name}\Parameter{layer list}\\
  \Macro{AddLayersAtBeginOfPageStyle}%
  \Parameter{page style name}\Parameter{layer list}\\
  \Macro{AddLayersAtEndOfPageStyle}%
  \Parameter{page style name}\Parameter{layer list}\\
  \Macro{RemoveLayersFromPageStyle}%
  \Parameter{page style name}\Parameter{layer list}%
\end{Declaration}
\BeginIndex{Cmd}{AddLayersToPageStyle}%
\BeginIndex{Cmd}{AddLayersAtBeginOfPageStyle}%
\BeginIndex{Cmd}{AddLayersAtEndOfPageStyle}%
\BeginIndex{Cmd}{RemoveLayersFromPageStyle}%
You can use these commands to add a layers to a layer page style or to remove 
layers from a layer page style. The page style will be referenced by it
\PName{page style name}. The layers are given by a comma separated
\PName{layer list}. 

The commands \Macro{AddLayersToPageStyle} and \Macro{AddLayersAtEndOfPageStyle}
add all layers of the comma separated list of layers \PName{layer list} at
the end of the layer list of layer page style \PName{page style
  name}. Logically the added layers would be above or in front of the old
layers of the page style. Nevertheless new background layers would be behind
the text layer and therefore behind all foreground layers.

Command \Macro{AddLayersAtBeginOfPageStyle} adds the new layers at the begin
of the layer list of the page style. Note, that the layers
will be added in the order of the \PName{layer list}. The first layer at
\PName{layer list} will be added first, the second layer will be added second
and so on. So with \Macro{AddLayersAtBeginOfPageStyle} the last layer at
\PName{layer list} will become the new first layer of the layer list of layer
page style \PName{page style name}.

Command \Macro{RemoveLayersFromPageStyle} may be used to remove layers from
the layer list of layer page style \PName{page style name} instead of adding
them. Note, that layers, that are part of \PName{layer list} but not part of
the page style's layer list, will be ignored. But adding or removing layers
from a page style, that is not a layer page style or an alias of a layer page
style would be an error and result in an error message.%
\EndIndex{Cmd}{RemoveLayersFromPageStyle}%
\EndIndex{Cmd}{AddLayersAtEndOfPageStyle}%
\EndIndex{Cmd}{AddLayersAtBeginOfPageStyle}%
\EndIndex{Cmd}{AddLayersToPageStyle}

\begin{Declaration}
  \Macro{AddLayersToPageStyleBeforeLayer}%
  \Parameter{page style name}\Parameter{layer list}%
  \Parameter{reference layer name}\\
  \Macro{AddLayersToPageStyleAfterLayer}%
  \Parameter{page style name}\Parameter{layer list}%
  \Parameter{reference layer name}
\end{Declaration}
\BeginIndex{Cmd}{AddLayersToPageStyleBeforeLayer}%
\BeginIndex{Cmd}{AddLayersToPageStyleAfterLayer}%
These commands are similar to the commands described before, but they do not
add the layers at the begin or end of the layer list of a layer page style,
but just before or after a reference layer at the layer list of a layer page
style. Note, that in this case the order of the \PName{layer list} will be
same in the layer list of \PName{page style name} after adding. If the
reference layer named \PName{reference layer name} is not part of the layer
list of the layer page style, nothing happens.%
\EndIndex{Cmd}{AddLayersToPageStyleAfterLayer}%
\EndIndex{Cmd}{AddLayersToPageStyleBeforeLayer}

\begin{Declaration}
  \Macro{UnifyLayersAtPageStyle}\Parameter{page style name}
\end{Declaration}
\BeginIndex{Cmd}{UnifyLayersAtPageStyle}%
With the commands described before in this section you may not only add
different layers to a page style, but even add the same layer several times to
a page style. In most cases it doesn't make sense to have one layer several
times at the layer list of a layer page style. So you may use
\Macro{UnifyLayersAtPageStyle} to remove all dupes of layers from the layer
list of a layer page style. 

Note\textnote{Attention!} that the order of layers may change! So if
you want a special order, you should remove all layers and add the layers in
the order you want instead of using \Macro{UnifyLayersAtPageStyle}.%
\EndIndex{Cmd}{UnifyLayersAtPageStyle}

\begin{Declaration}
  \Macro{ModifyLayerPageStyleOptions}%
  \Parameter{page style name}\Parameter{option list}\\
  \Macro{AddToLayerPageStyleOptions}%
  \Parameter{page style name}\Parameter{option list}
\end{Declaration}
\BeginIndex{Cmd}{ModifyLayerPageStyleOptions}%
\BeginIndex{Cmd}{AddToLayerPageStyleOptions}%
Command \Macro{ModifyLayerPageStyleOptions} may be used to modify the page
style options of a layer page style. Only options at the comma separated
\PName{option list} will be set to the new values given in \PName{option list}
if the new value is not empty. Options, that are not at \PName{option list},
will stay unchanged. If you want to set an option to \emph{do nothing} you may
use value \Macro{relax}. Note, that setting an option to a new value using
\Macro{ModifyLayerPageStyleOptions} will remove the previous value including
the global default value.

\Macro{AddToLayerPageStyleOptions} differs from
\Macro{ModifyLayerPageStyleOptions} in that point. It will not overwrite the
previous values, but adds\,---\,or more precisely: concatenates\,---\, the new
values to the previous values of the options at \PName{option list}.%
\EndIndex{Cmd}{AddToLayerPageStyleOptions}%
\EndIndex{Cmd}{ModifyLayerPageStyleOptions}%

\begin{Declaration}
  \Macro{IfLayerPageStyleExists}%
  \Parameter{page style name}\Parameter{then code}\Parameter{else code}\\
  \Macro{IfRealLayerPageStyleExists}%^
  \Parameter{page style name}\Parameter{then code}\Parameter{else code}%
\end{Declaration}
\BeginIndex{Cmd}{IfLayerPageStyleExists}%
\BeginIndex{Cmd}{IfRealLayerPageStyleExists}%
Command \Macro{IfLayerPageStyleExists} tests, whether or not the real page
style of \PName{page style name} is a layer page style. If the test is true,
\PName{then code} will be executed. If \PName{page style name} is neither a
layer page style, nor an alias of a layer page style, nor an alias of an alias
of \dots\ a layer page style, \PName{else code} will be executed. Internally
this command is often used to throw an error message if you use one of the
layer page style commands with an \PName{page style name} that doesn't
correspond with a layer page style.

Command \Macro{IfRealLayerPageStyleExists} is similar, but \PName{then code}
will only be executed, if \PName{page style name} itself is the name of a
layer page style. So \PName{else code} will even be executed, if \PName{page
  style name} is an alias name of a layer page style or the alias name of an
alias name of \dots\ a layer page style.%
\EndIndex{Cmd}{IfRealLayerPageStyleExists}%
\EndIndex{Cmd}{IfLayerPageStyleExists}%

\begin{Declaration}
  \Macro{IfLayerAtPageStyle}%
  \Parameter{page style name}\Parameter{layer name}%
  \Parameter{then code}\Parameter{else code}\\
  \Macro{IfSomeLayerAtPageStyle}%
  \Parameter{page style name}\Parameter{layer list}%^
  \Parameter{then code}\Parameter{else code}\\
  \Macro{IfLayerAtPageStyle}%
  \Parameter{page style name}\Parameter{layer list}%
  \Parameter{then code}\Parameter{else code}%
\end{Declaration}
\BeginIndex{Cmd}{IfLayerAtPageStyle}%
\BeginIndex{Cmd}{IfSomeLayersAtPageStyle}%
\BeginIndex{Cmd}{IfLayersAtPageStyle}%
Command \PName{IfLayerAtPageStyle} may be used to test, whether or not a layer
named \PName{layer name} is a member of the layer list of a given page
style. If the test is true, the \PName{then code} will be executed. If the
layer is not a member of the layer list of \PName{page style name}, the
\PName{else code} will be executed.

Commands \Macro{IfSomeLayerAtPageStyle} and \Macro{IfLayersAtPageStyle} do not
only test one layer but several layers at a given, comma separated
\PName{layer list}. \Macro{IfSomeLayerAtPageStyle} will execute the
\PName{then code} if \emph{at least one} of the layers at \PName{layer list}
is a member of the layer list of \PName{page style name}. In difference
\Macro{IfLayersAtPageStyle} executes the \PName{then code} only, if \emph{all}
of the layers at \PName{layer list} are members of the layer list of
\PName{page style name}.%
\EndIndex{Cmd}{IfLayersAtPageStyle}%
\EndIndex{Cmd}{IfSomeLayersAtPageStyle}%
\EndIndex{Cmd}{IfLayerAtPageStyle}

\begin{Declaration}
  \Macro{DestroyRealLayerPageStyle}\Parameter{page style name}
\end{Declaration}
\BeginIndex{Cmd}{DestroyRealLayerPageStyle}%
Command \Macro{DestroyRealLayerPageStyle} makes the page style named
\PName{page style name} undefined, if and only if it is a layer page
style. Nothing will be happen if it is an alias name of a layer page style, if
it is another page style, or if it isn't a page style. 

If \PName{page style name} is the name of the current page style the current
page style will become a kind of empty page style. If the special page
style\,---\,this may be set using \Macro{thispagestyle}\,---\,is \PName{page
  style name}, this will be simply reset. So the previous
\Macro{thispagestyle} will become invalid.

Note, that the layers of the page style won't be destroyed automatically. If
you want to destroy the layers too, you may use
\begin{lstcode}
  \ForEachLayerOfPageStyle{...}{\DestroyLayer{#1}}
\end{lstcode}
\emph{before} destroying the layer page style.

The command is intended to be used inside the auto-remove code of an interface
See following \ref{sec:scrlayer.enduserinterfaces} for more information about
auto-remove code.%
\EndIndex{Cmd}{DestroyRealLayerPageStyle}

\LoadCommon{20} % \section{Height of Page Head and Foot}

\LoadCommon{21} % \section{Manipulation of Defined Page Styles}

\section{End User Interfaces}
\label{sec:scrlayer.enduserinterfaces}

Package \Package{scrlayer} provides an interface to define and manage
(concurrent) end user interfaces. Maybe future releases of \KOMAScript{} will
provide parts of this by package \Package{scrbase} and remove those commands
from \Package{scrlayer}. But currently this part if \Package{scrlayer} is very
experimental, so package \Package{scrlayer} provides its own interface
definition commands. Currently you shouldn't depend on correct working of
auto-removing a concurrent end user interface. Instead you should avoid using
concurrent end user interfaces.

This section only describes the interface commands for defining end user
interfaces. This isn't interesting for end users, but only for authors of end
user interfaces. End users will find information about the end user interfaces
in the sections about the particular end user interface, e.g.,
\autoref{cha:scrlayer.scrpage}.

\begin{Declaration}
  \Macro{scrlayerInitInterface}\OParameter{interface name}
\end{Declaration}
\BeginIndex{Cmd}{scrlayerInitInterface}%
Command \Macro{scrlayerInitInterface}
registers a new interface. The \PName{interface name} must be unique. If you
try to initialise an already initialised interface an error will occur. This
command is obligatory and mandatory for interfaces. It should be the first
interface command and therefore has been described first. If the optional
argument is omitted, \PValue{\Macro{@currname}.\Macro{@currext}} will be
used instead. For classes and packages this will be the file name of the class
or package while loading the class or package. But you may use any sequence of
characters with category letter or other.%
\EndIndex{Cmd}{scrlayerInitInterface}

\begin{Declaration}
  \KOption{forceoverwrite}\PName{simple switch}\\
  \KOption{autoremoveinterfaces}\PName{simple switch}\\
  \Macro{scrlayerAddToInterface}%
  \OParameter{interface name}\Parameter{command}\Parameter{code}\\
  \Macro{scrlayerAddCsToInterface}%
  \OParameter{interface name}\Parameter{command sequence}\Parameter{code}
\end{Declaration}
\BeginIndex{Option}{forceoverwrite}%
\BeginIndex{Option}{autoremoveinterfaces}%
\BeginIndex{Cmd}{scrlayerAddToInterface}%
\BeginIndex{Cmd}{scrlayerAddCsToInterface}%
One of the special features of end user interfaces is, that they should
register all interface dependent commands (also known as \emph{macros}). You
may do this using \Macro{scrlayerAddToInterface}%^^A
. If your interface generates macros not only at load time but also at run
time or if the interface name shouldn't be the class's or package's name, you
have to use the optional argument to add the command to a dedicated
interface. An error will occur, if the interface hasn't been initialised
before.

The first mandatory argument is the \PName{command}\footnote{The
  \PName{command} consists in the backslash followed by a \PName{command
    sequence} consisting in characters with category code letter or one other
  character, or \PName{command} consists in one active character (without
  backslash).}, that should be added to the interface. If the command can be
added to the interface, it will be added to the interface, will be set to
\Macro{relax} and \PName{code} will be executed. You can use, e.g.,
\Macro{newcommand}\PName{command} inside of \PName{code} to define
\PName{command}.

But when can a command be defined? If a command is undefined or \Macro{relax}
it can be defined. If a command has already been defined and registered for
another interface \emph{and} if \KOMAScript{} option
\Option{autoremoveinterface} has been switched on, the other interface will be
removed automatically and the new command will be set to \Macro{relax} and
will be registered for the given interface. If a command
has already been defined but isn't part of another interface \emph{and} if
\KOMAScript{} option \Option{forceoverwrite} has been switched on, the command
will be set to \Macro{relax} and will be registered for the given interface.

Command \Macro{scrlayerAddCsToInterface} is similar to
\Macro{scrlayerAddToInterface} but doesn't expect a command as first,
mandatory argument, but a command sequence\footnote{A command sequence may
  consist of any characters with category code letter or other.}.%
\EndIndex{Cmd}{scrlayerAddCsToInterface}%
\EndIndex{Cmd}{scrlayerAddToInterface}
\EndIndex{Option}{autoremoveinterfaces}%
\EndIndex{Option}{forceoverwrite}%

\begin{Declaration}
  \Macro{scrlayerOnAutoRemoveInterface}%^^A
  \OParameter{interface name}\Parameter{code}
\end{Declaration}
\BeginIndex{Cmd}{scrlayerOnAutoRemoveInterface}%
Command \Macro{scrlayerOnAutoRemoveInterface}
registers \PName{code} to be executed, if the interface will be automatically
removed (see \Option{autoremoveinterfaces} prior in this section). This may be
used, e.g., to automatically destroy layers or page styles (see
\Macro{DestroyLayer}, \Macro{DestroyAliasPageStyle}, and
\Macro{DestroyRealLayerPageStyle}).%
\EndIndex{Cmd}{scrlayerOnAutoRemoveInterface}%
%
\EndIndex{Package}{scrlayer}

%%% Local Variables:
%%% mode: latex
%%% mode: flyspell
%%% coding: us-ascii
%%% ispell-local-dictionary: "en_GB"
%%% TeX-master: "../guide"
%%% End: 


