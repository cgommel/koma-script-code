% \CheckSum{985}
% \iffalse meta-comment
% ======================================================================
% scrkbase.dtx
% Copyright (c) Markus Kohm, 2002-2007
%
% This file is part of the LaTeX2e KOMA-Script bundle.
%
% This work may be distributed and/or modified under the conditions of
% the LaTeX Project Public License, version 1.3b of the license.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3b or later is part of all distributions of LaTeX 
% version 2005/12/01 or later and of this work.
%
% This work has the LPPL maintenance status "author-maintained".
%
% The Current Maintainer and author of this work is Markus Kohm.
%
% This work consists of all files listed in manifest.txt.
% ----------------------------------------------------------------------
% scrkbase.dtx
% Copyright (c) Markus Kohm, 2002-2007
%
% Dieses Werk darf nach den Bedingungen der LaTeX Project Public Lizenz,
% Version 1.3b, verteilt und/oder veraendert werden.
% Die neuste Version dieser Lizenz ist
%   http://www.latex-project.org/lppl.txt
% und Version 1.3b ist Teil aller Verteilungen von LaTeX
% Version 2005/12/01 oder spaeter und dieses Werks.
%
% Dieses Werk hat den LPPL-Verwaltungs-Status "author-maintained"
% (allein durch den Autor verwaltet).
%
% Der Aktuelle Verwalter und Autor dieses Werkes ist Markus Kohm.
% 
% Dieses Werk besteht aus den in manifest.txt aufgefuehrten Dateien.
% ======================================================================
% \fi
%
% \CharacterTable
%  {Upper-case    \A\B\C\D\E\F\G\H\I\J\K\L\M\N\O\P\Q\R\S\T\U\V\W\X\Y\Z
%   Lower-case    \a\b\c\d\e\f\g\h\i\j\k\l\m\n\o\p\q\r\s\t\u\v\w\x\y\z
%   Digits        \0\1\2\3\4\5\6\7\8\9
%   Exclamation   \!     Double quote  \"     Hash (number) \#
%   Dollar        \$     Percent       \%     Ampersand     \&
%   Acute accent  \'     Left paren    \(     Right paren   \)
%   Asterisk      \*     Plus          \+     Comma         \,
%   Minus         \-     Point         \.     Solidus       \/
%   Colon         \:     Semicolon     \;     Less than     \<
%   Equals        \=     Greater than  \>     Question mark \?
%   Commercial at \@     Left bracket  \[     Backslash     \\
%   Right bracket \]     Circumflex    \^     Underscore    \_
%   Grave accent  \`     Left brace    \{     Vertical bar  \|
%   Right brace   \}     Tilde         \~}
%
% \iffalse
%%% From File: scrkbase.dtx
%<*driver>
% \fi
\ProvidesFile{scrkbase.dtx}[2007/09/17 v2.97c KOMA-Script (basics)]
% \iffalse
%</driver>
%<package&option>\ProvidesPackage{scrkbase}[%
%<package&option>  \KOMAScriptVersion\space package (basics and keyval use)]
%<*driver>
\documentclass{scrdoc}
\usepackage[english,ngerman]{babel}
\usepackage[latin1]{inputenc}
\CodelineIndex
\RecordChanges
\GetFileInfo{scrkbase.dtx}
\title{\KOMAScript{} \partname\ \texttt{\filename}%
  \footnote{Dies ist Version \fileversion\ von Datei
    \texttt{\filename}.}}
\date{\filedate}
\author{Markus Kohm}

\begin{document}
  \maketitle
  \tableofcontents
  \DocInput{\filename}
\end{document}
%</driver>
% \fi
%
% \selectlanguage{ngerman}
%
% \changes{v1.0}{2002/07/06}{Beginn der ersten Version}
%
% \section{Grundlegenden \KOMAScript-Erweiterungen}
%
% Neue Versionen von \KOMAScript{} machen zunehmend Gebrauch vom
% \textsf{keyval}-Paket. Das \textsf{keyval}-Paket ist Bestandteil des
% \textsf{graphics}-Pakets und muss als solches auf allen
% \TeX-Systemen mit \LaTeX{} enthalten sein. Es genügt jedoch in
% einigen Punkten nicht den Anforderungen von \KOMAScript{}. Deshalb
% werden hier Erweiterungen vorgenommen, die von \KOMAScript-Klassen
% und \KOMAScript-Paketen verwendet werden können.
%
% Darüber hinaus werden immer mehr Teile von \KOMAScript{} von mehr
% als einem Paket oder von Paketen und Klassen verwendet. Diese
% grundlegenden Dinge wurden daher in ein eigenes Paket,
% \textsl{scrkbase}, ausgegliedert. Dadurch werden die Pakete und
% Klassen selbst kleiner und die können trotzdem unabhängig
% voneinander verwendet werden. Selbstverständlich kann man dieses
% Paket auch ohne den Rest von \KOMAScript{} zum Einsatz bringen.
%
% \StopEventually{\PrintIndex\PrintChanges}
%
% \iffalse
%<*load>
% \fi
%
% \subsection{Laden des Pakets}
% Wer das Paket lädt, tut das allerdings in der Regel sogar bereits
% vor der Definition der Optionen mit:
%    \begin{macrocode}
\RequirePackage{scrkbase}[\KOMAScriptVersion]
%    \end{macrocode}
%
% \iffalse
%</load>
%<*option>
% \fi
%
% \subsection{Laden von \textsf{keyval}}
%
% Hier wird nicht nur das Paket geladen, was ruckzuck mit:
%    \begin{macrocode}
\RequirePackage{keyval}
%    \end{macrocode}
% erledigt ist.
%
%
% \subsection{Anweisungen zur Abarbeitung von Optionen}
%
%  \begin{macro}{\scr@ifundefinedorrelax}
%    \changes{v2.95c}{2006/08/12}{neu (intern)}
%    \changes{v2.97b}{2007/03/08}{vermurkste Logik korrigiert}
%    \changes{v2.97c}{2007/04/18}{vermurkste Funktion korrigiert}
%    \changes{v2.97c}{2007/04/18}{von \cs{scr@ifundefined} umbenannt}
% Dieses Makro arbeitet wie \cs{@ifundefined}, definiert dabei aber
% ein undefiniertes Makro nicht als \cs{relax}. Es muss bereits hier definiert
% werden, weil es gleich verwendet wird.
%    \begin{macrocode}
\begingroup\expandafter\expandafter\expandafter\endgroup
\expandafter\ifx\csname ifcsname\endcsname\relax
  \newcommand{\scr@ifundefinedorrelax}[1]{%
    \begingroup\expandafter\expandafter\expandafter\endgroup
    \expandafter\ifx\csname #1\endcsname\relax
      \expandafter\@firstoftwo
    \else
      \expandafter\@secondoftwo
    \fi
  }
\else
  \newcommand{\scr@ifundefinedorrelax}[1]{%
    \ifcsname #1\endcsname
      \expandafter\ifx\csname #1\endcsname\relax
        \expandafter\expandafter\expandafter\@firstoftwo
      \else
        \expandafter\expandafter\expandafter\@secondoftwo
      \fi
    \else
      \expandafter\@firstoftwo
    \fi
  }
\fi
%    \end{macrocode}
%  \end{macro}
%
%
% \subsection{Definition von KOMA-\textsf{keyval}-Schlüsseln (Basis)}
%
% Üblicherweise verwendet \KOMAScript{} für alle
% \textsf{keyval}-Schlüssel die gleiche Bereichskennung
% "`\texttt{KOMA}"'. Dadurch ist es möglich, dass Pakete die Schlüssel
% der Klassen umdefinieren und dass jeder Teil von \KOMAScript{} die
% Schlüssel jedes anderen Teils ausführen kann -- sobald sie definiert
% sind.
%
% \begin{macro}{\KOMA@key}
%   \changes{v2.97c}{2007/04/19}{neues optionales Argument}
% \begin{macro}{\KOMA@key@familylist}
% \textsf{keyval}-Schlüssel für \KOMAScript{} werden mit \cs{KOMAkey}
% definiert, damit auch die Familie korrekt gesetzt und ggf. der Liste der
% Familien (\cs{KOMA@key@familylist}) hinzugefügt wird.
%    \begin{macrocode}
\newcommand*{\KOMA@key}[1][.\@currname.\@currext]{%
  \edef\reserved@a{\noexpand\in@{KOMA#1,}{\KOMA@key@familylist}}\reserved@a
  \ifin@\else\xdef\KOMA@key@familylist{\KOMA@key@familylist KOMA#1,}\fi
  \define@key{KOMA#1}%
}
\newcommand*{\KOMA@key@familylist}{}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Optionen}
%
% Ab Version 2.97c sollen sowohl globale KOMA-Optionen als auch die
% KOMA-Optionen der jeweiligen Datei als auch die normalen Optionen in der
% Reihenfolge ausgeführt werden, in der sie angegeben wurden -- zuerst die
% globalen Optionen, dann die lokalen. Dabei werden nur die Optionen
% verwendet, die auch für das jeweilige Paket bzw. die jeweilige Klasse
% definiert wurden.
%
% \begin{macro}{\@globaloptionslist}
%   \changes{v2.96}{2006/11/26}{new}
%   \changes{v2.96}{2006/11/26}{Klassenoptionen durchsuchen}
% Die Lister der globalen Optionen wird teilweise benötigt. Weil
% \textsl{xkeyval} dämlicherweise glaubt, es müsse alle Optionen mit
% Gleichheitszeichen aus der Liste der Klassenoptionen entfernen
% (seltsamerweise aber nicht die (x)keyval-Optionen, die ohne Wert aufgerufen
% werden, weil ihr Defaultwert verwendet werden soll), wird hier ein eigenes
% Makro definiert.
%    \begin{macrocode}
\newcommand*{\@globaloptionslist}{}
\let\@globaloptionslist\@classoptionslist
\scr@ifundefinedorrelax{XKV@classoptionslist}{}{%
  \ifx\XKV@classoptionslist\@empty\else
    \let\@globaloptionslist\XKV@classoptionslist
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\KOMAProcessOptions}
%   \changes{v2.97c}{2007/04/18}{neu}
% Diese Anweisung führt alle Optionen, sowohl normal deklarierte als auch
% keyval-Optionen eines Pakets bzw. einer Klasse in der Reihenfolge, in der
% sie verwendet wurden aus -- zuerst gloable Optionen, dann lokale
% Optionen. Das entspricht der Verwendung von \cs{ProcessOptions*} mit dem
% Unterschied, dass eben auch die keyval-Optionen abgearbeitet
% werden. keyval-Optionen, die keiner einzelnen Klasse und keinem einzelnen
% Paket zugeordnet werden, werden dabei vor gleichnamigen eigenen
% keyval-Optionen ausgeführt.
%    \begin{macrocode}
\newcommand*{\KOMAProcessOptions}[1][KOMA]{%
  \let\ds@\@empty
  \edef\@curroptions{\@ptionlist{\@currname.\@currext}}%
  \ifx\@currext\@clsextension\else
    \@for\CurrentOption:=\@globaloptionslist\do{%
      \ifx\CurrentOption\@empty\else
        \@expandtwoargs\in@{,\CurrentOption,}{,\@declaredoptions,}%
        \ifin@
          \@use@ption
          \expandafter\let\csname ds@\CurrentOption\endcsname\@empty
        \else
          \KOMA@optiontest{#1}\CurrentOption{}{%
            \@use@ption
            \@expandtwoargs\setkeys{#1}%
            \CurrentOption
          }%
          \KOMA@optiontest{#1.\@currname.\@currext}\CurrentOption{}{%
            \@use@ption
            \@expandtwoargs\setkeys{#1.\@currname.\@currext}%
            \CurrentOption
          }%
        \fi
      \fi
    }%
  \fi
  \@for\CurrentOption:=\@curroptions\do{%
    \@use@ption
    \scr@ifundefinedorrelax{ds@\CurrentOption}{%
      \KOMA@optiontest{#1}\CurrentOption{%
        \KOMA@optiontest{#1.\@currname.\@currext}\CurrentOption{%
          \default@ds
        }{%
          \let\scr@sr@co\CurrentOption
          \@expandtwoargs\setkeys{#1.\@currname.\@currext}%
          \CurrentOption
          \let\CurrentOption\scr@sr@co
        }%
      }{%
        \@expandtwoargs\setkeys{#1}%
        \CurrentOption
        \KOMA@optiontest{#1.\@currname.\@currext}\CurrentOption{}{%
          \@expandtwoargs\setkeys{#1.\@currname.\@currext}%
          \CurrentOption
        }%
      }%
    }{%
    }%
  }%
  \@for\CurrentOption:=\@declaredoptions\do{%
    \expandafter\let\csname ds@\CurrentOption\endcsname\relax}%
  \let\CurrentOption\@empty
  \let\@fileswith@pti@ns\@@fileswith@pti@ns
  \AtEndOfPackage{\let\@unprocessedoptions\relax}%
}
\@onlypreamble\KOMA@process@options
\@onlypreamble\KOMAProcessOptions
%    \end{macrocode}
% \begin{macro}{\KOMA@optiontest}
%   \changes{v2.97c}{2007/04/18}{neu (intern)}
% \begin{macro}{\KOMA@pti@ntest}
%   \changes{v2.97c}{2007/04/18}{neu (intern)}
% Es werden zwei interne Makros benötigt, um zu testen, ob eine entsprechende
% keyval-Option definiert ist. Grund der Übung ist, dass sowohl das
% Familienargument als auch die Options selbst expandiert werden muss.
%    \begin{macrocode}
\newcommand*{\KOMA@optiontest}[2]{%
  \edef\reserved@a{\noexpand\KOMA@pti@ntest{#1}#2=\noexpand\@nil}%
  \reserved@a
}
\newcommand*{\KOMA@pti@ntest}{}
\def\KOMA@pti@ntest#1#2=#3\@nil{\scr@ifundefinedorrelax{KV@#1@#2}}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \begin{macro}{\scr@sr@co}
%    \changes{v2.96}{2006/08/20}{neu (intern)}
% Da das \texttt{xkeyval}-Paket leider \cs{CurrentOption} vernichtet, das aber
% innerhalb von \cs{ProcessOptions} und \cs{KOMAProcessOptions} nach dem
% Ausführen der Option noch benötigt wird, muss die Anweisung gesichert
% werden. Dafür wird ein Hilfsmakro benötigt.
%    \begin{macrocode}
\newcommand*{\scr@sr@co}{}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{option}{internalonly}
%   \changes{v2.96}{2006/11/26}{neu}
%   \changes{v2.97c}{2007/06/20}{geht auch ohne Argument}
% \begin{macro}{\dont@let@as@internal@defined}
%   \changes{2.96}{2006/11/26}{neu (intern)}
% Anweisungen, die mit einem internen und einem Anwendername vorhanden sind,
% können vor dem Anwender optional verborgen werden. Wird kein Argument
% angegeben, so werden alle Anweisungen verborgen.
%    \begin{macrocode}
\newcommand*{\dont@let@as@internal@defined}{/}
\newif\if@let@as@internalonly@defined\@let@as@internalonly@definedfalse
\KOMA@key{internalonly}[\relax]{%
  \ifx\relax#1\relax
    \@let@as@internalonly@definedtrue
  \else
    \@let@as@internalonly@definedfalse
    \begingroup
      \@expandtwoargs\in@{#1}\dont@let@as@internal@defined
    \expandafter\endgroup
    \ifin@\else\g@addto@macro\dont@let@as@internal@defined{#1/}\fi
  \fi
}
%    \end{macrocode}
% \end{macro}
% \end{option}
%
% \changes{v2.96}{2006/08/20}{Optionen werden abgearbeitet}
% \changes{v2.97c}{2007/04/18}{Optionen werden mit \cs{KOMAProcessOptions}
%   abgearbeitet}
%    \begin{macrocode}
\KOMAProcessOptions\relax
%    \end{macrocode}
%
% \iffalse
%</option>
%<*body>
% \fi
%
% \subsection{Häufig benötigte Befehle}
%
%  \begin{macro}{\if@atdocument}
%    \changes{v2.95}{2002/12/05}{neuer Schalter}
%  \begin{macro}{\@atdocumenttrue}
%  \begin{macro}{\@atdocumentfalse}
% Dieser Schalter wird bei \cs{begin}\texttt{\{document\}} wahr. Er
% wird von \KOMAScript{} für Befehle verwendet, die sich
% unterschiedlich verhalten, je nachdem, ob sie in der Präambel oder
% danach aufgerufen werden.
%    \begin{macrocode}
\newif\if@atdocument
\AtBeginDocument{\@atdocumenttrue}
\@onlypreamble\@atdocumentrue
\@onlypreamble\@atdocumentfalse
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
% \begin{macro}{\let@as@internal@defined}
%   \changes{v2.95}{2002/08/19}{neu (intern)}
%   \changes{v2.95c}{2006/08/12}{Warnung bei Umdefinierung}
%   \changes{v2.96}{2006/11/26}{Herausreichen von internen Makros als
%     Benutzermakros kann verhindert werden}
%   \changes{v2.97c}{2007/06/20}{Herausreichen von internen Makros kann
%     generell verhindert werden}
% Dieses Makro wird intern verwendet, um dokumentierte Makros mit der
% Definition von internen Makros zu versehen, falls sie nicht bereits
% definiert oder als nicht zu definieren markiert sind. Der Name des
% dokumentierten Makros wird als Parameter übergeben. Dies wird gleich
% benötigt.
%    \begin{macrocode}
\newcommand*{\let@as@internal@defined}[1]{%
  \begingroup
    \if@let@as@internalonly@defined
      \in@true
    \else
      \@expandtwoargs\in@{/#1/}\dont@let@as@internal@defined
    \fi
  \expandafter\endgroup
  \ifin@
    \PackageInfo{%
      scrkbase%
    }{%
      \expandafter\string\csname #1\endcsname\space excluded from being
      defined%
    }%
  \else
    \@ifundefined{#1}{%
      \begingroup
        \expandafter\def\expandafter\@tempa
          \expandafter{\csname scr@#1\endcsname}
        \expandafter\def\expandafter\@tempb
          \expandafter{\csname #1\endcsname}
      \expandafter\expandafter\expandafter\endgroup
      \expandafter\expandafter\expandafter\let\expandafter\@tempb\@tempa
      \if@atdocument\else
        \g@addto@macro\document{%
          \expandafter\ifx\csname #1\expandafter\endcsname
          \csname scr@#1\endcsname
          \else
            \PackageWarning{scrkbase}{%
              \expandafter\string\csname #1\endcsname\space was
              redefined\MessageBreak
              at the document preamble.\MessageBreak
              If you did not redefine it by yourself, have a\MessageBreak
              a look at the description of this command at\MessageBreak
              the manual of every package you are using\@gobble
            }%
          \fi
        }%
      \fi
    }{%
      \PackageInfo{%
        scrkbase%
      }{%
        \expandafter\string\csname #1\endcsname\space already
        defined.\MessageBreak
        If \expandafter\string\csname #1\endcsname\space does not behave
        like\MessageBreak
        it was described at the KOMA-Script manual, try to\MessageBreak
        load `scrkbase.sty' earlier or find out at which\MessageBreak
        package or class \expandafter\string\csname #1\endcsname\space
        was defined before\@gobble
      }%
    }%
  \fi
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\ifundefinedorrelax}
%    \changes{v2.95}{2002/08/21}{neu}
%    \changes{v2.95c}{2006/08/12}{über interne Anweisung definiert}
%    \changes{v2.97c}{2007/06/20}{umbenannt von \cs{ifundefined}}
% Dieses Makro arbeitet wie \cs{@ifundefined}, definiert dabei aber
% ein undefiniertes Makro nicht als \cs{relax}.
%    \begin{macrocode}
\let@as@internal@defined{ifundefinedorrelax}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\ifnotundefined}
%    \changes{v2.95}{2002/08/21}{neu}
%    \changes{v2.95c}{2006/08/12}{nutzt \eTeX{} wenn möglich}
% Dieses Makro arbeitet genau umgekehrt zu \cs{ifundefined}. Manchmal
% ist es ganz nützlich, auch das zu haben. Dieses Makro heißt nicht
% \cs{ifdefined}, weil \eTeX\ bereits ein solches Primitiv bietet.
%    \begin{macrocode}
\scr@ifundefinedorrelax{ifcsname}{%
  \newcommand{\ifnotundefined}[1]{%
    \begingroup\expandafter\expandafter\expandafter\endgroup
    \expandafter\ifx\csname #1\endcsname\relax
      \expandafter\@secondoftwo
    \else
      \expandafter\@firstoftwo
    \fi
  }%
}{%
  \newcommand{\ifnotundefined}[1]{%
    \ifcsname #1\endcsname
      \expandafter\@firstoftwo
    \else
      \expandafter\@secondoftwo
    \fi
  }%
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\ifstr}
%    \changes{v2.95}{2004/07/20}{if- und then-Teil werden nicht gefressen}
% Dieses Makro vergleicht zwei Tokenfolgen. Eigentlich müsste es also
% eher \cs{ifequal} oder ähnlich heißen.
%    \begin{macrocode}
\newcommand\ifstr[2]{%
  \begingroup\edef\@tempa{#1}\edef\@tempb{#2}%
  \ifx\@tempa\@tempb
    \endgroup\expandafter\@firstoftwo
  \else
    \endgroup\expandafter\@secondoftwo
  \fi
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\ifnumber}
% Dieses Makro testet, ob ein übergebener Parameter eine positive,
% ganze Zahl ist. Ist dies der Fall, wird der zweite Parameter
% ausgeführt, sonst der dritte.
%    \begin{macrocode}
\newcommand\ifnumber[1]{%
  \begingroup\@tempswafalse\let\scr@next\test@number
  \expandafter\scr@next#1\scr@next
  \if@tempswa
    \endgroup\expandafter\@firstoftwo
  \else
    \endgroup\expandafter\@secondoftwo
  \fi
}
%    \end{macrocode}
%  \begin{macro}{\test@number}
% Für den eigentlichen Test wird der erste Parameter Token für Token
% gescannt und beurteilt.
%    \begin{macrocode}
\newcommand*{\test@number}[1]{%
  \ifx \scr@next#1
    \let\scr@next\relax
  \else
%    \end{macrocode}
% Dabei wird für einen schnelleren Vergleich die Tatsache genutzt, dass
% Ziffernzeichen immer im selben durchgängigen Bereich liegen
%    \begin{macrocode}
    \@tempcnta=\expandafter\expandafter\expandafter\number
    \expandafter`#1\relax
    \ifnum \@tempcnta>47
      \ifnum \@tempcnta<58
        \@tempswatrue
      \else\@tempswafalse\fi
    \else\@tempswafalse\fi
%    \end{macrocode}
% Das zeichenweise Scannen und Parsen kann natürlich nicht einfach
% abgebrochen werden. Stattdessen ist der Parameterrest noch zu
%  entfernen.
%    \begin{macrocode}
    \if@tempswa\else\let\scr@next\gobble@till@scr@next\fi
  \fi
  \scr@next
}
%    \end{macrocode}
%  \begin{macro}{\gobble@tillscr@@next}
% Das geschieht mit einem einzigen "`Leermacro"'.
%    \begin{macrocode}
\newcommand*{\gobble@till@scr@next}{}
\def\gobble@till@scr@next#1\scr@next{}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\ifdimen}
% Dieses Makro testet, ob ein übergebener Parameter eine Dimension
% ist und führt in Abhängigkeit davon den zweiten oder dritten
% Parameter aus.
%    \begin{macrocode}
\newcommand{\ifdimen}[1]{%
  \begingroup\@tempswatrue\let\scr@next\test@posdimen
  \expandafter\test@dimen#1\scr@next
  \if@tempswa
    \endgroup\expandafter\@firstoftwo
  \else
    \endgroup\expandafter\@secondoftwo
  \fi
}
%    \end{macrocode}
%  \begin{macro}{\test@dimen}
% Als erste muss ein Vorzeichen entfernt werden.
%    \begin{macrocode}
\newcommand*{\test@dimen}[1]{%
  \ifx -#1\else\ifx +#1\else
      \def\scr@next{\let\scr@next\test@posdimen\scr@next#1}\fi\fi
  \scr@next
}
%    \end{macrocode}
%  \begin{macro}{\test@posdimen}
% Dann muss getestet werden, ob es sich beim Rest um eine Dimension
% handelt. Dabei werden der Einfachheit halber mehrere Dezimalkomma
% und -punkte erlaubt. Natürlich könnte man es auch wirklich richtig
% machen, aber das wäre nochmal etwas aufwendiger. Ist das wirklich
% notwendig? 
%    \begin{macrocode}
\newcommand*{\test@posdimen}[1]{%
  \ifx \scr@next#1%
    \@tempswafalse\let\scr@next\relax
  \else
    \if .#1\else\if ,#1\else
        \@tempcnta=%
        \expandafter\expandafter\expandafter\number\expandafter`#1\relax
        \ifnum \@tempcnta>47
          \ifnum \@tempcnta<58
          \else\def\scr@next{\test@dimunt#1}\fi
        \else\def\scr@next{\test@dimunt#1}\fi
    \fi\fi
  \fi
  \scr@next
}
%    \end{macrocode}
%  \begin{macro}{\testdimunt}
%  \begin{macro}{\test@trueunt}
% Außer einer Gleitkomma- bzw. Gleitpunktzahl muss auch noch die Einheit
% behandelt werden. Dabei sind sowohl die neun Standardeinheiten als auch
% deren "`true"'-Variante zu berücksichtigen. Deshalb wird zuerst ein
% eventuelles "`\texttt{true}"' weggeworfen.
%    \begin{macrocode}
\newcommand*{\test@dimunt}{}
\def\test@dimunt#1\scr@next{%
  \expandafter\test@trueunt#1truetrue\test@trueunt
}
\newcommand*{\test@trueunt}{}
\def\test@trueunt#1true#2true#3\test@trueunt{%
  \edef\@tempa{#1}
  \ifx\@tempa\@empty\test@@ifdimunt{#2}\else\test@@ifdimunt{#1}\fi
}
%    \end{macrocode}
%  \begin{macro}{\test@@ifdimunt}
% Anschließend wird dann getestet, ob es sich um eine der neun üblichen
% Einheiten handelt.
%    \begin{macrocode}
\newcommand*\test@@ifdimunt[1]{%
  \@tempswafalse
  \ifstr{#1}{pt}{\@tempswatrue}{%
    \ifstr{#1}{pc}{\@tempswatrue}{%
      \ifstr{#1}{in}{\@tempswatrue}{%
        \ifstr{#1}{bp}{\@tempswatrue}{%
          \ifstr{#1}{cm}{\@tempswatrue}{%
            \ifstr{#1}{mm}{\@tempswatrue}{%
              \ifstr{#1}{dd}{\@tempswatrue}{%
                \ifstr{#1}{cc}{\@tempswatrue}{%
                  \ifstr{#1}{sp}{\@tempswatrue}{}%
                }%
              }%
            }%
          }%
        }%
      }%
    }%
  }%
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
%
%  \begin{macro}{\ifpdftex}
%    \changes{v2.95}{2002/08/19}{neu}
%  \begin{macro}{\scr@ifpdftex}
%    \changes{v2.95}{2002/08/19}{neu (intern)}
% If-then-else-Konstrukt, um zu testen, ob pdf\TeX{} verwendet wird.
%    \begin{macrocode}
\newcommand{\scr@ifpdftex}{\ifnotundefined{pdftexversion}}
\let@as@internal@defined{ifpdftex}
\BeforePackage{pdfcprot}{\let\ifpdftex\relax}
\AfterPackage{pdfcprot}{\let@as@internal@defined{ifpdftex}}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  
% \begin{macro}{\ifVTeX}
%   \changes{v2.95}{2002/08/19}{neu}
%   \changes{v2.97c}{2007/06/20}{umdefiniert von \cs{ifvtex}}
% \begin{macro}{\scr@ifVTeX}
%   \changes{v2.95}{2002/08/19}{neu}
%   \changes{v2.97c}{2007/06/20}{umdefiniert von \cs{scr@ifvtex}}
% If-then-else-Konstrukt, um zu testen, ob V\TeX{} verwendet wird.
%    \begin{macrocode}
\newcommand{\scr@ifVTeX}{\ifnotundefined{VTeXversion}}
\let@as@internal@defined{ifVTeX}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\ifpdfoutput}
%    \changes{v2.7g}{2001/04/17}{neu}
%    \changes{v2.8q}{2001/10/19}{\cs{pdfoutput} wird nicht mehr zu
%      \cs{relax}, wenn zuvor undefiniert}
%    \changes{v2.8q}{2001/10/19}{darf bereits definiert sein}
%    \changes{v2.8q}{2001/10/19}{Verwendung von \cs{scr@ifpdfoutput}}
%  \begin{macro}{\scr@ifpdfoutput}
%    \changes{v2.8q}{2001/10/19}{neu (intern)}
%    \changes{v2.8q}{2001/11/13}{funktioniert}
%    \changes{v2.95}{2002/08/21}{berücksichtigt V\TeX}
%    \changes{v2.95}{2004/07/20}{Expandierbarkeit verbessert}
% If-then-else-Konstrukt, um abhängig davon, ob als \texttt{pdf}
% ausgegeben wird oder nicht, Befehle auszuführen. Dieses Makro wird
% für die Deklaration der Option \texttt{pagesize} benötigt.
%    \begin{macrocode}
\newcommand{\scr@ifpdfoutput}{%
  \scr@ifundefinedorrelax{pdfoutput}{%
    \scr@ifundefinedorrelax{OpMode}{%
      \expandafter\@secondoftwo%
    }{%
      \ifnum\OpMode=1
        \expandafter\@firstoftwo
      \else
        \expandafter\@secondoftwo
      \fi
    }%
  }{%
    \ifnum\pdfoutput>0 
      \expandafter\@firstoftwo
    \else
      \expandafter\@secondoftwo
    \fi
  }%
}%
\let@as@internal@defined{ifpdfoutput}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\ifpsoutput}
%    \changes{v2.95}{2002/08/21}{neu}
%  \begin{macro}{\scr@ifpsoutput}
%    \changes{v2.95}{2002/08/21}{neu (intern)}
%    \changes{v2.95}{2004/07/20}{Expandierbarkeit verbessert}
% If-then-else-Konstrukt, um abhängig davon, ob früher oder später
% \texttt{ps} ausgegeben wird oder nicht, Befehle auszuführen.
%    \begin{macrocode}
\newcommand*{\scr@ifpsoutput}{%
  \ifnotundefined{if@dvips}{%
    \if@dvips 
      \expandafter\@firstoftwo
    \else 
      \expandafter\@secondoftwo
    \fi
  }{%
    \ifnotundefined{OpMode}{%
      \ifnum\OpMode=2
        \expandafter\@firstoftwo
      \else
        \expandafter\@secondoftwo
      \fi
    }{%
      \expandafter\@secondoftwo
    }%
  }%
}
\let@as@internal@defined{ifpsoutput}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\ifdvioutput}
%    \changes{v2.95}{2002/08/21}{neu}
%  \begin{macro}{\scr@ifdvioutput}
%    \changes{v2.95}{2002/08/21}{neu (intern)}
%    \changes{v2.95}{2004/07/20}{Expandierbarkeit verbessert}
% If-then-else-Konstrukt, um abhängig davon, ob \texttt{dvi}
% ausgegeben wird oder nicht, Befehle auszuführen.
%    \begin{macrocode}
\newcommand*{\scr@ifdvioutput}{%
  \scr@ifundefinedorrelax{pdfoutput}{%
    \scr@ifundefinedorrelax{OpMode}{%
      \expandafter\@firstoftwo
    }{%
      \ifnum\OpMode=0
        \expandafter\@firstoftwo
      \else
        \expandafter\@secondoftwo
      \fi
    }%
  }{%
    \ifnum\pdfoutput=0
      \expandafter\@firstoftwo
    \else
      \expandafter\@secondoftwo
    \fi
  }%
}
\let@as@internal@defined{ifdvioutput}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
% \begin{macro}{\scr@smashdp}
%   \changes{v2.97c}{2007/09/17}{neu (intern)}
% Gibt Material aus, erzeugt dabei aber nur Höhe und Breite, jedoch keine
% Tiefe.
%    \begin{macrocode}
\newcommand*{\scr@smashdp}[1]{%
  \begingroup
    \def\finsm@sh{\dp\z@\z@\box\z@}%
    \smash{#1}%
  \endgroup
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \subsection{Definition von KOMA-\textsf{keyval}-Schlüsseln (Hauptteil)}
%
% \begin{macro}{\KOMAExecuteOptions}
%   \changes{v2.97c}{2007/04/19}{neu (nur für Klassen- und Paketautoren)}
% Liste von Optionen ausführen
%    \begin{macrocode}
\newcommand*{\KOMAExecuteOptions}[2][KOMA]{%
  \def\reserved@a##1\@nil{%
    \@for\KOMA@key@atlist:=#2\do{%
      \expandafter\KOMA@key@split@name@value\KOMA@key@atlist==\@nil
      \scr@ifundefinedorrelax{KV@#1@\KOMA@key@name}{}{%
        \edef\reserved@a{\noexpand\setkeys{#1}{\KOMA@key@atlist}%
        }%
        \reserved@a
      }%
      \scr@ifundefinedorrelax{KV@#1.\@currname.\@currext @\KOMA@key@name}{}{%
        \edef\reserved@a{%
          \noexpand\setkeys{#1.\@currname.\@currext}{\KOMA@key@atlist}%
        }%
        \reserved@a
      }%
      \let\CurrentOption\KOMA@key@atlist
      \csname ds@\CurrentOption\endcsname
    }%
    \edef\CurrentOption{##1}%
  }%
  \expandafter\reserved@a\CurrentOption\@nil
}
\@onlypreamble\KOMAExecuteOptions
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\KOMAoptions}
%   \changes{v2.96}{2006/08/20}{Neuer Hook nach den Optionen}
%   \changes{v2.97c}{2007/04/19}{Optionen aller KOMA-Familien abarbeiten}
% \begin{macro}{\post@kopt@hook}
%   \changes{v2.96}{2006/08/20}{Neuer Hook nach den Optionen}
% \begin{macro}{\AfterKOMAoptions}
%   \changes{v2.96}{2006/08/20}{Neuer Hook nach den Optionen}
% Es werden Schlüssel verwendet und ggf. danach noch Dinge ausgeführt.
%    \begin{macrocode}
\newcommand*{\KOMAoptions}[1]{%
  \let\post@kopt@hook\@empty
  \KOMA@options{#1}{%
% Wenn der Schlüssel für keine der bekannten Familien definiert ist, wird ein
% Fehler ausgegeben.
%    \begin{macrocode}
    \PackageError{scrkbase}{%
      unknown KOMA option `\KOMA@key@name'%
    }{%
      You have used \string\KOMAoptions\space to set
      `\KOMA@key@atlist',\MessageBreak
      but KOMA-Script does not know any option named
      `\KOMA@key@name'.\MessageBreak
      See the KOMA-Script manual for more informations about options
      and\MessageBreak
      their values.%
    }%
  }%
  \post@kopt@hook\let\post@kopt@hook\relax
}
%    \end{macrocode}
% \begin{macro}{\KOMA@options}
%   \changes{v2.97c}{2007/04/19}{Neues Makro (intern)}
% Das interne Macro \cs{KOMA@options} macht die eigentliche Arbeit. Das erste
% Argument ist dabei die Liste der Optionen, das zweite Code, der im
% Fehlerfall ausgeführt werden soll. Dabei sind die Makros
% \cs{KOMA@key@atlist}, \cs{KOMA@key@name} und \cs{KOMA@key@value} gültig und
% können verwendet werden.
%
% Anmerkung: Es wird nicht auf \textsf{ykeyval} und den dortigen Befehl
% \cs{setkeys+} gesetzt, weil dieser die Optionen nicht in der Reihenfolge der
% Optionen, sondern in der Reihenfolge der Familien ausführt. Das passt mir
% aber hier gar nicht.
%
% In einer Schleife über alle Optionen werden die Optionen zunächst in Option
% und Wert aufgespaltet.
%    \begin{macrocode}
\newcommand*{\KOMA@options}[2]{%
  \@for\KOMA@key@atlist:=#1\do{%
    \expandafter\KOMA@key@split@name@value\KOMA@key@atlist==\@nil
%    \end{macrocode}
% Dann wird in einer Schleife über alle Familien festgestellt, ob die Option
% in einer Familie bekannt ist und ggf. ausgeführt.
%    \begin{macrocode}
    \KOMA@key@found@false
    \@for\@tempa:=\KOMA@key@familylist\do{%
      \scr@ifundefinedorrelax{KV@\@tempa @\KOMA@key@name}{}{%
        \KOMA@key@found@true
        \edef\reserved@a{\noexpand\setkeys{\@tempa}{\KOMA@key@atlist}%
          \noexpand\edef\noexpand\@tempa{\@tempa}%
          \noexpand\edef\noexpand\KOMA@key@atlist{\KOMA@key@atlist}%
          \noexpand\edef\noexpand\KOMA@key@name{\KOMA@key@name}%
          \noexpand\edef\noexpand\KOMA@key@value{\KOMA@key@value}%
        }%
        \reserved@a
      }%
    }%
    \ifKOMA@key@found@\else#2\fi
  }%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ifKOMA@key@found@}
%   \changes{v2.97c}{2007/04/19}{Neuer Schalter (intern)}
% \begin{macro}{\KOMA@key@atlist}
%   \changes{v2.97c}{2007/04/19}{Neues Makro (intern)}
% \begin{macro}{\KOMA@key@name}
%   \changes{v2.97c}{2007/04/19}{Neues Makro (intern)}
% \begin{macro}{\KOMA@key@value}
%   \changes{v2.97c}{2007/04/19}{Neues Makro (intern)}
% \begin{macro}{\KOMA@key@split@name@value}
%   \changes{v2.97c}{2007/04/19}{Neues Makro (intern)}
%    \begin{macrocode}
\newif\ifKOMA@key@found@
\newcommand*{\KOMA@key@atlist}{}
\newcommand*{\KOMA@key@name}{}
\newcommand*{\KOMA@key@value}{}
\newcommand*{\KOMA@key@split@name@value}{}
\def\KOMA@key@split@name@value#1=#2=#3\@nil{%
  \def\KOMA@key@name{#1}%
  \def\KOMA@key@value{#2}%
}
\newcommand*{\post@kopt@hook}{}
\let\post@kopt@hook\relax
\newcommand*{\AfterKOMAoptions}{%
  \ifx\post@kopt@hook\relax
    \PackageWarning{scrkbase}{%
      \string\AfterKOMAoptions\space can only be used inside a\MessageBreak
      KOMA-Script option that is called using \space\KOMAoptions.\MessageBreak
      Because if this, command will be ignored%
    }%
    \expandafter\@gobbletwo
  \else
    \expandafter\l@addto@macro
  \fi
  \post@kopt@hook
}
%    \end{macrocode}
% \begin{macro}{\l@addto@macro}
%   \changes{v2.8p}{2001/09/22}{neu (intern)} 
%   Damit \cs{AfterKOMAoptions} lokal möglich ist, wird eine lokal arbeitende
%   Variante von \cs{g@addto@macro} benötigt, wie sie hier vorgestellt wird.
%   \changes{v2.95}{2006/06/02}{korrigiert, damit es sich bezüglich
%     Erweiterung um Makrodefinitonen mit Argumenten wie \cs{g@addto@macro}
%     verhält}
%    \begin{macrocode}
\scr@ifundefinedorrelax{unexpanded}{%
  \newcommand*{\g@addto@macro@temp}{}%
  \newcommand{\l@addto@macro}[2]{%
    \begingroup%
      \toks@\expandafter{#1#2}%
      \xdef\g@addto@macro@temp{\the\toks@}%
    \endgroup
    \let#1\g@addto@macro@temp
  }%
}{%
  \newcommand{\l@addto@macro}[2]{%
    \edef#1{\unexpanded\expandafter{#1#2}}%
  }%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
%  \begin{macro}{\KOMA@unknown@keyval}
% Dieses Makro berichtet über Fehler wegen unbekannter Wertübergabe an
% einen Schlüssel. Das erste Argument ist der Schlüssel, das zweite
% der Wert und das dritte die Liste der möglichen Werte.
%    \begin{macrocode}
\newcommand*{\KOMA@unknown@keyval}[3]{%
  \PackageError{%
    scrkbase%
  }{%
    KOMA option `#1' has no value `#2'%
  }{%
    You've tried to set option `#1' to value `#2'.\MessageBreak
    But allowed values are only:\MessageBreak
    #3.\MessageBreak
    See the KOMA-Script manual for more information.%
  }%
}
%    \end{macrocode}
%  \end{macro}
%
%  \begin{macro}{\KOMA@ifkey}
% Dieses Makro definiert einen Schlüssel, der einen Schalter an Hand des
% Wertes setzt. Als Werte sind "`\texttt{true}"', "`\texttt{false}"',
% "`\texttt{on}"', "`\texttt{off}"', "`\texttt{yes}"' und
% "`\texttt{no}"' erlaubt. Der Default-Wert für den Schalter ist
% grundsätzlich "`false"', so dass der Default-Wert für die Verwendung
% des Schküssels grundsätzlich "`true"' ist. Das erste Argument ist
% der Name des Schlüssels, der zweite ist der Name des Schalters. 
%    \begin{macrocode}
\newcommand*{\KOMA@ifkey}[2]{%
  \@ifundefined{if#2}{%
    \expandafter\newif\csname if#2\endcsname
  }{}%
  \KOMA@key{#1}[true]{\KOMA@set@ifkey{#1}{#2}{##1}}%
}
%    \end{macrocode}
%  \begin{macro}{\KOMA@set@ifkey}
% Die eigentliche Arbeit bei der ganzen Sache wird von diesem internen
% Makro erledigt. Dabei wird der Name des Schlüssels zu Argument 1, der
% Name des Schalters zu Argument 2 und der Wert des Schlüssels wird
% Argument 3.
%    \begin{macrocode}
\newcommand*{\KOMA@set@ifkey}[3]{%
  \ifstr{#3}{true}{\@nameuse{#2true}}{%
    \ifstr{#3}{on}{\@nameuse{#2true}}{%
      \ifstr{#3}{yes}{\@nameuse{#2true}}{%
        \ifstr{#3}{false}{\@nameuse{#2false}}{%
          \ifstr{#3}{off}{\@nameuse{#2false}}{%
            \ifstr{#3}{no}{\@nameuse{#2false}}{%
              \KOMA@unknown@keyval{#1}{#3}{%
                `true', `on', `yes', `false', `off', `no'%
              }%
            }%
          }%
        }%
      }%
    }%
  }%
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%
%  \begin{macro}{\KOMA@ncmdkey}
% Ein ähnliches Makro definiert einen Schlüssel, der ein nummerisches
% Makro auf einen bestimmten Wert setzt. Dabei können auch
% verschiedene symbolische Werte auf denselben nummerischen Wert
% abgebildet werden. Das erste Argument ist obligatorisch und der Name
% des Schlüssels. Das zweite Argument ist optional und der Defaultwert
% für den Schlüssel. Das dritte Argument ist obligatorisch und der
% Name des Makros, das definiert werden soll. Der Defaultwert dafür
% ist 0. Das vierte Argument ist obligatorisch und die Liste der
% symbolischen und nummerischen Wert. Die Liste hat die Form: 
% \{\emph{Symbol}\}\{\emph{Wert}\},\{\emph{Symbol}\}\{\emph{Wert}\}\dots
%  \begin{macro}{\KOMA@@ncmdkey}
% Da nicht das erste, sondern das zweite Argument optional ist, wird
% ein Hilfsmakro benötigt.
%    \begin{macrocode}
\newcommand*{\KOMA@ncmdkey}[1]{%
  \@ifnextchar [%]
    {\KOMA@@ncmdkey{#1}}{\KOMA@@ncmdkey{#1}[]}%
}
\newcommand*{\KOMA@@ncmdkey}{}
\def\KOMA@@ncmdkey#1[#2]#3#4{%
  \ifx\relax#2\relax\else
    \@namedef{KV@KOMA@#1@default\expandafter}\expandafter{%
      \csname KV@KOMA@#1\endcsname{#2}%
    }%
  \fi
  \@ifundefined{#3}{\@namedef{#3}{0}}%
  \KOMA@key{#1}{\KOMA@set@ncmdkey{#1}{#3}{#4}{##1}}%
}
%    \end{macrocode}
%  \begin{macro}{\KOMA@set@ncmdkey}
% Die eigentliche Arbeit dabei wird von diesem Makro erledigt. Dabei
% wird der Name des Schlüssels zu Argument 1, der Name des Makros,
% das definiert werden soll zu Argument 2, die Liste zu Argument 3 und
% der Wert, auf den gesetzt werden soll, zu Argument 4.
%    \begin{macrocode}
\newcommand*{\KOMA@set@ncmdkey}[4]{%
  \begingroup
    \edef\@searched{#4}%
    \let\@tempa=\@empty
    \let\@tempb=\@empty
    \@tempswafalse
    \@for\@valuelist:=#3\do{%
      \if@tempswa\else
        \edef\@tempc{\expandafter\@firstoftwo\@valuelist}%
        \edef\@tempa{\@tempa\@tempb`\@tempc'}%
        \edef\@tempb{, }%
        \ifx\@tempc\@searched
          \@tempswatrue
          \edef\@tempa{\expandafter\@secondoftwo\@valuelist}%
        \fi
      \fi
    }%
    \if@tempswa
      \edef\@tempa{\endgroup
        \noexpand\@namedef{#2}{\@tempa}%
      }%
    \else
      \KOMA@unknown@keyval{#1}{#4}{\@tempa}%
      \let\@tempa=\endgroup
    \fi
  \@tempa
}
%    \end{macrocode}
%  \end{macro}
%  \end{macro}
%  \end{macro}
%
% \begin{macro}{\KOMA@DeclareObsoleteOption}
%   \changes{v2.96}{2006/08/20}{\cs{CurrentOption wir geschützt}}
% Mit Hilfe dieses Makros kann eine Option definiert werden, die
% eigentlich obsolete ist. Statt dieser Option wird dann ein Schlüssel
% verwendet. Das erste Argument ist optional und muss dann entweder
% \cs{PackageInfo}, \cs{PackageInfoNoLine}, \cs{PackageWarning} oder
% \cs{PackageWarningNoLine} sein. Das zweite Argument ist der Name der
% Option. Das dritte Argument ist das Setzen des gewünschten Schlüssels.
%    \begin{macrocode}
\newcommand*{\KOMA@DeclareObsoleteOption}[3][\@gobbletwo]{%
  \DeclareOption{#2}{\KOMA@UseObsoleteOption{#1}{#2}{#3}}%
}
%    \end{macrocode}
% \begin{macro}{\KOMA@UseObsoleteOption}
%   \changes{v2.97c}{2007/04/19}{neu (intern)}
% Die eigentliche Arbeit wird von diesem Makro erledigt. Die Argumente sind
% dieselben.
%    \begin{macrocode}
\newcommand*{\KOMA@UseObsoleteOption}[3]{%
  \let\scr@sr@co\CurrentOption
  #1{scrkbase}{%
    You've used obsolete option `#2'.\MessageBreak
    \protect\KOMAExecuteOptions{#3} will be\MessageBreak
    used instead.\MessageBreak
    You may simply replace `#2'\MessageBreak
    by `#3'%
  }%
  \KOMAExecuteOptions{#3}%
  \let\CurrentOption\scr@sr@co
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\KOMA@newobsoletecommand}
% Mit Hilfe dieses Makros kann ein Makro definiert werden, das
% eigentlich obsolete ist. Das Makro verwendet dann schlicht einen
% Schlüssel. Das erste Argument ist optional und muss dann entweder
% \cs{PackageInfo}, \cs{PackageInfoNoLine}, \cs{PackageWarning} oder
% \cs{PackageWarningNoLine} sein. Das zweite Argument ist das Makro.
% Das dritte Argument ist das Setzen des gewünschten Schlüssels. Das
% definierte Makro selbst hat Schaltercharakter, ist also nicht
% \cs{long} und versteht auch keine Argumente.
%    \begin{macrocode}
\newcommand*{\KOMA@newobsoletecommand}[3][\@gobbletwo]{%
  \newcommand*{#2}{\KOMA@UseObsoleteCommand{#1}{\string#2}{#3}}%
}
%    \end{macrocode}
% \begin{macro}{\KOMA@UseObsoleteCommand}
%   \changes{v2.97c}{2007/04/19}{neu (intern)}
% Die eigentliche Arbeit wird von diesem Makro erledigt. Die Argumente sind
% dieselben.
%    \begin{macrocode}
\newcommand*{\KOMA@UseObsoleteCommand}[3]{%
  #1{%
    scrkbase%
  }{%
    You've used the obsolete command `#2'.\MessageBreak
    \protect\KOMAoptions{#3} will be used instead.\MessageBreak
    You should also replace `#2' by `\protect\KOMAoptions{#3}'%
  }%
  \KOMAoptions{#3}%
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%
% \iffalse
%</body>
% \fi
%
% \Finale
%
\endinput
%
% end of file `scrkbase.dtx'
%%% Local Variables:
%%% mode: doctex
%%% TeX-master: t
%%% End:
